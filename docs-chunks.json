[
  {
    "id": "index-0",
    "text": "Agents · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Ship your first Agent Why build agents on Cloudflare? Build on the Cloudflare Platform On this page Overview Ship your first Agent Why build agents on Cloudflare? Build on the Cloudflare Platform Tags AI Was this helpful? Edit Issue Directory Agents Copy page Build Agents on Cloudflare The Agents SDK enables you to build and deploy AI-powered agents that can autonomously perform tasks, communicate with clients in real time, call AI models, persist state, schedule tasks, run asynchronous workflows, browse the web, query data from your database, support human-in-the-loop interactions, and a lot more . Ship your first Agent To use the Agent starter template and create your first Agent with the Agents SDK: Terminal window # install it npm create cloudflare@latest agents-starter -- --template=cloudflare/agents-starter # and deploy it npx wrangler@latest deploy Head to the guide on building a chat agent to learn how the starter project is built and how to use it as a foundation for your own agents. If you're already building on Workers , you can install the agents package directly into an existing project: Terminal window npm i agents And then define your first Agent by creating a class that extends the Agent class: JavaScript TypeScript JavaScript import { Agent , AgentNamespace } from \"agents\" ; export class MyAgent extends Agent { // Define methods on the Agent: // https://developers.cloudflare.com/agents/api-reference/agents-api/ // // Every Agent has built in state via this.setState and this.sql // Built-in scheduling via this.schedule // Agents support WebSockets, HTTP requests, state synchronization and // can run for seconds, minutes or hours: as long as the tasks need. } TypeScript import { Agent , AgentNamespace } from \"agents\" ; export class MyAgent extends Agent { // Define methods on the Agent: // https://developers.cloudflare.com/agents/api-reference/agents-api/ // // Every Agent has built in state via this.setState and this.sql // Built-in scheduling via this.schedule // Agents support WebSockets, HTTP requests, state synchronization and // can run for seconds, minutes or hours: as long as the tasks need. } Lastly, add the Durable Objects binding to your wrangler file: wrangler.jsonc wrangler.toml { \" $schema \" : \"./node_modules/wrangler/config-schema.json\" , \" durable_objects \" : { \" bindings \" : [ { \" name \" : \"MyAgent\" , \" class_name \" : \"MyAgent\" } ] }, \" migrations \" : [ { \" tag \" : \"v1\" , \" new_sqlite_classes \" : [ \"MyAgent\" ] } ] } [[ durable_objects . bindings ]] name = \"MyAgent\" class_name = \"MyAgent\" [[ migrations ]] tag = \"v1\" new_sqlite_classes = [ \"MyAgent\" ] Dive into the Agent SDK reference to learn more about how to use the Agents SDK package and defining an Agent . Why build agents on Cloudflare? We built the Agents SDK with a few things in mind: Batteries (state) included : Agents come with built-in state management , with the ability to automatically sync state between an Agent and clients, trigger events on state changes, and read+write to each Agent's SQL database. Communicative : You can connect to an Agent via WebSockets and stream updates back to client in real-time. Handle a long-running response from a reasoning model, the results of an asynchronous workflow , or build a chat app that builds on the useAgent hook included in the Agents SDK. Extensible : Agents are code. Use the AI models you want, bring-your-own headless browser service, pull data from your database hosted in another cloud, add your own methods to your Agent and call them. Agents built with Agents SDK can be deployed directly to Cloudflare and run on top of Durable Objects — which you can think of as stateful micro-servers that can scale to tens of millions — and are able to run wherever they need to. Run your Agents close to a user for low-latency interactivity, close to your data for throughput, and/or anywhere in between. Build on the Cloudflare Platform Workers Build serverless applications and deploy instantly across the globe for exceptional performance, reliability, and scale. AI Gateway Observe and control your AI applications with caching, rate limiting, request retries, model fallback, and more. Vectorize Build full-stack AI applications with Vectorize, Cloudflare’s vector database. Adding Vectorize enables you to perform tasks such as semantic search, recommendations, anomaly detection or can be used to provide context and memory to an LLM. Workers AI Run machine learning models, powered by serverless GPUs, on Cloudflare's global network. Workflows Build stateful agents that guarantee executions, including automatic retries, persistent state that runs for minutes, hours, days, or weeks. Was this helpful? Edit page Last updated: Aug 19, 2025 Next Build a Chat Agent ↗ Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Build a Chat Agent · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview On this page Overview Was this helpful? Edit Issue Directory … Agents Getting started Build a Chat Agent Copy page Build a Chat Agent Was this helpful? Edit page Last updated: Mar 18, 2025 Next Overview Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Testing your Agents · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Writing and running tests Setup Add the Agent configuration Write a test Run tests Running Agents locally On this page Overview Writing and running tests Setup Add the Agent configuration Write a test Run tests Running Agents locally Was this helpful? Edit Issue Directory … Agents Getting started Testing your Agents Copy page Testing your Agents Because Agents run on Cloudflare Workers and Durable Objects, they can be tested using the same tools and techniques as Workers and Durable Objects. Writing and running tests Setup Note The agents-starter template and new Cloudflare Workers projects already include the relevant vitest and @cloudflare/vitest-pool-workers packages, as well as a valid vitest.config.js file. Before you write your first test, install the necessary packages: Terminal window npm install vitest@~3.0.0 --save-dev --save-exact npm install @cloudflare/vitest-pool-workers --save-dev Ensure that your vitest.config.js file is identical to the following: JavaScript import { defineWorkersConfig } from \"@cloudflare/vitest-pool-workers/config\" ; export default defineWorkersConfig ( { test : { poolOptions : { workers : { wrangler : { configPath : \"./wrangler.toml\" }, }, }, }, } ) ; Add the Agent configuration Add a durableObjects configuration to vitest.config.js with the name of your Agent class: JavaScript import { defineWorkersConfig } from \"@cloudflare/vitest-pool-workers/config\" ; export default defineWorkersConfig ( { test : { poolOptions : { workers : { main : \"./src/index.ts\" , miniflare : { durableObjects : { NAME : \"MyAgent\" , }, }, }, }, }, } ) ; Write a test Note Review the Vitest documentation ↗ for more information on testing, including the test API reference and advanced testing techniques. Tests use the vitest framework. A basic test suite for your Agent can validate how your Agent responds to requests, but can also unit test your Agent's methods and state. TypeScript import { env , createExecutionContext , waitOnExecutionContext , SELF , } from \"cloudflare:test\" ; import { describe , it , expect } from \"vitest\" ; import worker from \"../src\" ; import { Env } from \"../src\" ; interface ProvidedEnv extends Env {} describe ( \"make a request to my Agent\" , () => { // Unit testing approach it ( \"responds with state\" , async () => { // Provide a valid URL that your Worker can use to route to your Agent // If you are using routeAgentRequest, this will be /agent/:agent/:name const request = new Request &#x3C; unknown , IncomingRequestCfProperties > ( \"http://example.com/agent/my-agent/agent-123\" , ) ; const ctx = createExecutionContext () ; const response = await worker . fetch ( request , env , ctx ) ; await waitOnExecutionContext ( ctx ) ; expect ( await response . text ()) . toMatchObject ( { hello : \"from your agent\" } ) ; } ) ; it ( \"also responds with state\" , async () => { const request = new Request ( \"http://example.com/agent/my-agent/agent-123\" ) ; const response = await SELF . fetch ( request ) ; expect ( await response . text ()) . toMatchObject ( { hello : \"from your agent\" } ) ; } ) ; } ) ; { // Unit testing approach it(&#x22;responds with state&#x22;, async () => { // Provide a valid URL that your Worker can use to route to your Agent // If you are using routeAgentRequest, this will be /agent/:agent/:name const request = new Request ( &#x22;http://example.com/agent/my-agent/agent-123&#x22;, ); const ctx = createExecutionContext(); const response = await worker.fetch(request, env, ctx); await waitOnExecutionContext(ctx); expect(await response.text()).toMatchObject({ hello: &#x22;from your agent&#x22; }); }); it(&#x22;also responds with state&#x22;, async () => { const request = new Request(&#x22;http://example.com/agent/my-agent/agent-123&#x22;); const response = await SELF.fetch(request); expect(await response.text()).toMatchObject({ hello: &#x22;from your agent&#x22; }); });});\"> Run tests Running tests is done using the vitest CLI: Terminal window $ npm run test # or run vitest directly $ npx vitest MyAgent ✓ should return a greeting (1 ms ) Test Files 1 passed (1) Review the documentation on testing for additional examples and test configuration. Running Agents locally You can also run an Agent locally using the wrangler CLI: Terminal window $ npx wrangler dev Your Worker and resources are simulated locally via Miniflare. For more information, see: https://developers.cloudflare.com/workers/testing/local-development. Your worker has access to the following bindings: - Durable Objects: - MyAgent: MyAgent Starting local server... [ wrangler:inf ] Ready on http://localhost:53645 This spins up a local development server that runs the same runtime as Cloudflare Workers, and allows you to iterate on your Agent's code and test it locally without deploying it. Visit the wrangler dev ↗ docs to review the CLI flags and configuration options. Was this helpful? Edit page Last updated: May 16, 2025 Previous Build a Chat Agent ↗ Next Prompt an AI model ↗ Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/getting-started/testing-your-agent/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Agents · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview What are agents? Example: Booking vacations Three primary components of agent systems: On this page Overview What are agents? Example: Booking vacations Three primary components of agent systems: Tags AI LLM Was this helpful? Edit Issue Directory … Agents Concepts Agents Copy page Agents What are agents? An agent is an AI system that can autonomously execute tasks by making decisions about tool usage and process flow. Unlike traditional automation that follows predefined paths, agents can dynamically adapt their approach based on context and intermediate results. Agents are also distinct from co-pilots (e.g. traditional chat applications) in that they can fully automate a task, as opposed to simply augmenting and extending human input. Agents → non-linear, non-deterministic (can change from run to run) Workflows → linear, deterministic execution paths Co-pilots → augmentative AI assistance requiring human intervention Example: Booking vacations If this is your first time working with, or interacting with agents, this example will illustrate how an agent works within a context like booking a vacation. If you are already familiar with the topic, read on. Imagine you're trying to book a vacation. You need to research flights, find hotels, check restaurant reviews, and keep track of your budget. Traditional workflow automation A traditional automation system follows a predetermined sequence: Takes specific inputs (dates, location, budget) Calls predefined API endpoints in a fixed order Returns results based on hardcoded criteria Cannot adapt if unexpected situations arise AI Co-pilot A co-pilot acts as an intelligent assistant that: Provides hotel and itinerary recommendations based on your preferences Can understand and respond to natural language queries Offers guidance and suggestions Requires human decision-making and action for execution Agent An agent combines AI's ability to make judgements and call the relevant tools to execute the task. An agent's output will be nondeterministic given: Real-time availability and pricing changes Dynamic prioritization of constraints Ability to recover from failures Adaptive decision-making based on intermediate results An agents can dynamically generate an itinerary and execute on booking reservations, similarly to what you would expect from a travel agent. Three primary components of agent systems: Decision Engine : Usually an LLM (Large Language Model) that determines action steps Tool Integration : APIs, functions, and services the agent can utilize Memory System : Maintains context and tracks task progress How agents work Agents operate in a continuous loop of: Observing the current state or task Planning what actions to take, using AI for reasoning Executing those actions using available tools (often APIs or MCPs ↗ ) Learning from the results (storing results in memory, updating task progress, and preparing for next iteration) Was this helpful? Edit page Last updated: Aug 15, 2025 Previous Prompt an AI model ↗ Next Workflows Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/concepts/what-are-agents/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Agent class internals · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview What is the Agent? Layer 0: Durable Object constructor RPC fetch() WebSockets alarm() this.ctx this.ctx.storage this.ctx.env Layer 1: Partykit Server Addressing onStart onRequest and onConnect WebSockets this.name Layer 2: Agent this.state and this.setState() this.sql RPC and Callable Methods this.queue and friends this.schedule and friends this.mcp and friends Email Handling Context Management this.onError this.destroy Routing On this page Overview What is the Agent? Layer 0: Durable Object constructor RPC fetch() WebSockets alarm() this.ctx this.ctx.storage this.ctx.env Layer 1: Partykit Server Addressing onStart onRequest and onConnect WebSockets this.name Layer 2: Agent this.state and this.setState() this.sql RPC and Callable Methods this.queue and friends this.schedule and friends this.mcp and friends Email Handling Context Management this.onError this.destroy Routing Was this helpful? Edit Issue Directory … Agents Concepts Agent class internals Copy page Agent class internals The core of the agents library is the exported Agent class. Following the pattern from Durable Objects , the main API for developers is to extend the Agent class to inherit all the built-in features. While this effectively is a supercharged primitive that allows developers to only write the logic they need in their agents, it obscures the inner workings. This document tries to bridge that gap, empowering any developer aiming to get started writing agents to get the full picture and avoid common pitfalls. The snippets shown here are primarily illustrative, and do not necessarily represent best practices. For a more in-depth look at the inner workings of the Agent class, check out the API reference and the source code ↗ . What is the Agent? The Agent class is an extension of DurableObject . That is to say, they are Durable Objects. If you are not familiar with Durable Objects, it is highly recommended that you read What are Durable Objects , but at their core, Durable Objects are globally addressable (each instance has a unique ID) single-threaded compute instances with long term storage (key-value/SQLite). Note that Agent does not extend DurableObject directly, but instead extends Server . Server is a class provided by PartyKit ↗ . You can visualize the logic as a Matryoshka doll: DurableObject > Server > Agent . Layer 0: Durable Object Let's briefly consider which primitives are exposed by Durable Objects so we understand how the outer layers make use of them. The Durable Object class comes with: constructor TypeScript constructor ( ctx : DurableObjectState , env : Env ) {} The Workers runtime always calls the constructor to handle things internally. This means two things: While the constructor is called every time the Durable Object is initialized, the signature is fixed. Developers cannot add or update parameters from the constructor. Instead of instantiating the class manually, developers must use the binding APIs and do it through the DurableObjectNamespace . RPC By writing a Durable Object class which inherits from the built-in type DurableObject , public methods are exposed as RPC methods, which developers can call using a DurableObjectStub from a Worker . TypeScript // This instance could've been active, hibernated, // not initialized or maybe had never even been created! const stub = env . MY_DO . getByName ( \"foo\" ) ; // We can call any public method of the class since. The runtime // **ensures** the constructor is called for us if the instance wasn't active. await stub . bar () ; fetch() Durable Objects can take a Request from a Worker and send a Response back. This can only be done through the fetch method (which the developer must implement). WebSockets Durable Objects include first-class support for WebSockets . A Durable Object can accept a WebSocket it receives from a Request in fetch and forget about it. The base class provides methods that developers can implement that are called as callbacks. They effectively replace the need for event listeners. The base class provides webSocketMessage(ws, message) , webSocketClose(ws, code, reason, wasClean) and webSocketError(ws , error) ( API ). TypeScript export class MyDurableObject extends DurableObject { async fetch ( request ) { // Creates two ends of a WebSocket connection. const webSocketPair = new WebSocketPair () ; const [ client , server ] = Object . values ( webSocketPair ) ; // Calling `acceptWebSocket()` connects the WebSocket to the Durable Object, allowing the WebSocket to send and receive messages. this . ctx . acceptWebSocket ( server ) ; return new Response ( null , { status : 101 , webSocket : client } ) ; } async webSocketMessage ( ws , message ) { // echo back the messages ws . send ( msg ) ; } } alarm() HTTP and RPC requests are not the only entrypoints for a Durable Object. Alarms allow developers to schedule an event to trigger at a later time. Whenever the next alarm is due, the runtime will call the alarm() method, which is left to the developer to implement. To schedule an alarm, you can use the this.ctx.storage.setAlarm() method. For more information, refer to Alarms . this.ctx The base DurableObject class sets the DurableObjectState into this.ctx . There are a lot of interesting methods and properties, but we will focus on this.ctx.storage . this.ctx.storage DurableObjectStorage is the main interface with the Durable Object's persistence mechanisms, which include both a KV and SQLITE synchronous APIs. TypeScript const sql = this . ctx . storage . sql ; const kv = this . ctx . storage . kv ; // An example of a synchronous SQL query const rows = sql . exec ( \"SELECT * FROM contacts WHERE country = ?\" , \"US\" ) ; // And an example of the synchronous KV const token = kv . get ( \"someToken\" ) ; this.ctx.env Lastly, it is worth mentioning that the Durable Object also has the Worker Env in this.env . Learn more in Bindings . Layer 1: Partykit Server Now that you have seen what Durable Objects come with out-of-the-box, what PartyKit ↗ 's Server (package partyserver ) implements will be clearer. It is an opinionated DurableObject wrapper that improves DX by hiding away Durable Object primitives in favor of more developer friendly callbacks. An important note is that Server does NOT persist to the Durable Object storage, so you will not see extra storage operations by using it. Addressing partyserver exposes helper to address your Durable Objects instead of manually through your bindings. This allows partyserver to implement several improvements, including a unique URL routing scheme for your Durable Objects (e.g. &#x3C;your-worker>/servers/:durableClass/:durableName ). Compare this to the Durable Object addressing example above . TypeScript // Note the await here! const stub = await getServerByName ( env . MY_DO , \"foo\" ) ; // We can still call RPC methods. await stub . bar () ; Since we have a URL addressing scheme, we also get access to routePartykitRequest() . TypeScript async fetch ( request : Request , env : Env , ctx : ExecutionContext ) { // Behind the scenes, PartyKit normalizes your DO binding names // and tries to do some pattern matching. const res = await routePartykitRequest ( request , env ) ; if ( res ) return res ; return Response ( \"Not found\" , { status : 404 } ) ; } You can also refer to the implementation ↗ to learn more. onStart The extra plumbing that Server includes on addressing allows it to expose an onStart callback that is executed every time the Durable Object starts up (the Durable Object was evicted, hibernated or never created at all) and before any fetch or RPC. TypeScript class MyServer extends Server { onStart () { // Some initialization logic that you wish // to run every time the DO is started up. const sql = this . ctx . storage . sql ; sql . exec ( `...` ) ; } } onRequest and onConnect Server already implements fetch for the underlying Durable Object and exposes two different callbacks that developers can make use of, onRequest and onConnect for HTTP requests and incoming WS connections, respectively (WebSocket connections are accepted by default). TypeScript class MyServer extends Server { async onRequest ( request : Request ) { const url = new URL ( request . url ) ; return new Response ( `Hello from ${ url . origin } !` ) ; } async onConnect ( conn , ctx ) { const { request } = ctx ; const url = new URL ( request . url ) ; // Connections are a WebSocket wrapper conn . send ( `Hello from ${ url . origin } !` ) ; } } WebSockets Just as onConnect is the callback for every new connection, Server also provides wrappers on top of the default callbacks from the DurableObject class: onMessage , onClose and onError . There's also this.broadcast that sends a WS message to all connected clients (no magic, just a loop over this.getConnections() !). this.name It is hard to get a Durable Object's name from within it. partyserver tries to make it available in this.name but it is not a perfect solution. Learn more about it in this GitHub issue ↗ . Layer 2: Agent Now finally, the Agent class. Agent extends Server and provides opinionated primitives for stateful, schedulable, and observable agents that can communicate via RPC, WebSockets, and (even!) email. this.state and this.setState() One of the core features of Agent is automatic state persistence . Developers define the shape of their state via the generic parameter and initialState (which is only used if no state exists in storage), and the Agent handles loading, saving, and broadcasting state changes (check Server 's this.broadcast() above). this.state is a getter that lazily loads state from storage (SQL). State is persisted across Durable Object evictions when it is updated with this.setState() , which automatically serializes the state and writes it back to storage. There's also this.onStateUpdate that you can override to react to state changes. TypeScript class MyAgent extends Agent &#x3C; Env , { count : number }> { initialState = { count : 0 }; increment () { this . setState ( { count : this . state . count + 1 } ) ; } onStateUpdate ( state , source ) { console . log ( \"State updated:\" , state ) ; } } { initialState = { count: 0 }; increment() { this.setState({ count: this.state.count + 1 }); } onStateUpdate(state, source) { console.log(&#x22;State updated:&#x22;, state); }}\"> State is stored in the cf_agents_state SQL table. State messages are sent with type: \"cf_agent_state\" (both from the client and the server). Since the agents provides JS and React clients , real-time state updates are available out of the box. this.sql The Agent provides a convenient sql template tag for executing queries against the Durable Object's SQL storage. It constructs parameterized queries and executes them. This uses the synchronous SQL API from this.ctx.storage.sql . TypeScript class MyAgent extends Agent { onStart () { this . sql ` CREATE TABLE IF NOT EXISTS users ( id TEXT PRIMARY KEY, name TEXT ) ` ; const userId = \"1\" ; const userName = \"Alice\" ; this . sql `INSERT INTO users (id, name) VALUES ( ${ userId } , ${ userName } )` ; const users = this . sql &#x3C;{ id : string ; name : string }> ` SELECT * FROM users WHERE id = ${ userId } ` ; console . log ( users ) ; // [{ id: \"1\", name: \"Alice\" }] } } &#x60; SELECT * FROM users WHERE id = ${userId} &#x60;; console.log(users); // [{ id: &#x22;1&#x22;, name: &#x22;Alice&#x22; }] }}\"> RPC and Callable Methods agents take Durable Objects RPC one step forward by implementing RPC through WebSockets, so clients can also call methods on the Agent directly. To make a method callable through WS, developers can use the @callable decorator. Methods can return a serializable value or a stream (when using @callable({ stream: true }) ). TypeScript class MyAgent extends Agent { @ callable ( { description : \"Add two numbers\" } ) async add ( a : number , b : number ) { return a + b ; } } Clients can invoke this method by sending a WebSocket message: { \" type \" : \"rpc\" , \" id \" : \"unique-request-id\" , \" method \" : \"add\" , \" args \" : [ 2 , 3 ] } For example, with the provided React client, it is as easy as: TypeScript const { stub } = useAgent ( { name : \"my-agent\" } ) ; const result = await stub . add ( 2 , 3 ) ; console . log ( result ) ; // 5 this.queue and friends Agents include a built-in task queue for deferred execution. This is useful for offloading work or retrying operations. The available methods are this.queue , this.dequeue , this.dequeueAll , this.dequeueAllByCallback , this.getQueue , and this.getQueues . TypeScript class MyAgent extends Agent { async onConnect () { // Queue a task to be executed later await this . queue ( \"processTask\" , { userId : \"123\" } ) ; } async processTask ( payload : { userId : string }, queueItem : QueueItem ) { console . log ( \"Processing task for user:\" , payload . userId ) ; } } Tasks are stored in the cf_agents_queues SQL table and are automatically flushed in sequence. If a task succeeds, it is automatically dequeued. this.schedule and friends Agents support scheduled execution of methods by wrapping the Durable Object's alarm() . The available methods are this.schedule , this.getSchedule , this.getSchedules , this.cancelSchedule . Schedules can be one-time, delayed, or recurring (using cron expressions). Since Durable Objects only allow one alarm at a time, the Agent class works around this by managing multiple schedules in SQL and using a single alarm. TypeScript class MyAgent extends Agent { async foo () { // Schedule at a specific time await this . schedule ( new Date ( \"2025-12-25T00:00:00Z\" ) , \"sendGreeting\" , { message : \"Merry Christmas!\" } ) ; // Schedule with a delay (in seconds) await this . schedule ( 60 , \"checkStatus\" , { check : \"health\" } ) ; // Schedule with a cron expression await this . schedule ( \"0 0 * * *\" , \"dailyTask\" , { type : \"cleanup\" } ) ; } async sendGreeting ( payload : { message : string }) { console . log ( payload . message ) ; } async checkStatus ( payload : { check : string }) { console . log ( \"Running check:\" , payload . check ) ; } async dailyTask ( payload : { type : string }) { console . log ( \"Daily task:\" , payload . type ) ; } } Schedules are stored in the cf_agents_schedules SQL table. Cron schedules automatically reschedule themselves after execution, while one-time schedules are deleted. this.mcp and friends Agent includes a multi-server MCP client. This enables your Agent to interact with external services that expose MCP interfaces. The MCP client is properly documented in MCP client API . TypeScript class MyAgent extends Agent { async onConnect () { // Add an MCP server await this . addMcpServer ( \"GitHub\" , \"https://mcp.example.com/sse\" , \"https://my-worker.example.workers.dev\" , // callback host for OAuth \"agents\" // routing prefix ) ; } } Email Handling Agents can receive and reply to emails using Cloudflare's Email Routing . TypeScript class MyAgent extends Agent { async onEmail ( email : AgentEmail ) { console . log ( \"Received email from:\" , email . from ) ; console . log ( \"Subject:\" , email . headers . get ( \"subject\" )) ; const raw = await email . getRaw () ; console . log ( \"Raw email size:\" , raw . length ) ; // Reply to the email await this . replyToEmail ( email , { fromName : \"My Agent\" , subject : \"Re: \" + email . headers . get ( \"subject\" ) , body : \"Thanks for your email!\" , contentType : \"text/plain\" } ) ; } } To route emails to your Agent, use routeAgentEmail in your Worker's email handler: TypeScript export default { async email ( message , env , ctx ) { await routeAgentEmail ( message , env , { resolver : createAddressBasedEmailResolver ( \"my-agent\" ) } ) ; } }; Context Management agents wraps all your methods with an AsyncLocalStorage to maintain context throughout the request lifecycle. This allows you to access the current agent, connection, request, or email (depending of what event is being handled) from anywhere in your code: TypeScript import { getCurrentAgent } from \"agents\" ; function someUtilityFunction () { const { agent , connection , request , email } = getCurrentAgent () ; if ( agent ) { console . log ( \"Current agent:\" , agent . name ) ; } if ( connection ) { console . log ( \"WebSocket connection ID:\" , connection . id ) ; } } this.onError Agent extends Server 's onError so it can be used to handle errors that are not necessarily WebSocket errors. It is called with a Connection or unknown error. TypeScript class MyAgent extends Agent { onError ( connectionOrError : Connection | unknown , error ?: unknown ) { if ( error ) { // WebSocket connection error console . error ( \"Connection error:\" , error ) ; } else { // Server error console . error ( \"Server error:\" , connectionOrError ) ; } // Optionally throw to propagate the error throw connectionOrError ; } } this.destroy this.destroy() drops all tables, deletes alarms, clears storage, and aborts the context. To ensure that the Durable Object is fully evicted, this.ctx.abort() is called, which throws an uncatchable error that will show up in your logs (read more about it in abort() ). TypeScript class MyAgent extends Agent { async onStart () { console . log ( \"Agent is starting up...\" ) ; // Initialize your agent } async cleanup () { // This wipes everything! await this . destroy () ; } } Routing The Agent class re-exports PartyKit's addressing helpers as getAgentByName and routeAgentRequest . TypeScript // Same API as getServerByName const stub = await getAgentByName ( env . MY_DO , \"foo\" ) ; // ... // Same API as routeServerRequest const res = await routeAgentRequest ( request , env ) ; if ( res ) return res ; return Response ( \"Not found\" , { status : 404 } ) ; Was this helpful? Edit page Last updated: Nov 7, 2025 Previous Tools Next Human in the Loop Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/concepts/agent-class/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Agents API · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Agent class API WebSocket API State synchronization API Scheduling API SQL API MCP Client API Client API React API Chat Agent Chat Agent React API Next steps On this page Overview Agent class API WebSocket API State synchronization API Scheduling API SQL API MCP Client API Client API React API Chat Agent Chat Agent React API Next steps Was this helpful? Edit Issue Directory … Agents API Reference Agents API Copy page Agents API This page provides an overview of the Agent SDK API, including the Agent class, methods and properties built-in to the Agents SDK. The Agents SDK exposes two main APIs: The server-side Agent class. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, how to call AI models, and any error handling. The client-side AgentClient class, which allows you to connect to an Agent instance from a client-side application. The client APIs also include React hooks, including useAgent and useAgentChat , and allow you to automatically synchronize state between each unique Agent (running server-side) and your client applications. Note Agents require Cloudflare Durable Objects , see Configuration to learn how to add the required bindings to your project. You can also find more specific usage examples for each API in the Agents API Reference . JavaScript TypeScript JavaScript import { Agent } from \"agents\" ; class MyAgent extends Agent { // Define methods on the Agent } export default MyAgent ; TypeScript import { Agent } from \"agents\" ; class MyAgent extends Agent { // Define methods on the Agent } export default MyAgent ; An Agent can have many (millions of) instances: each instance is a separate micro-server that runs independently of the others. This allows Agents to scale horizontally: an Agent can be associated with a single user, or many thousands of users, depending on the agent you're building. Instances of an Agent are addressed by a unique identifier: that identifier (ID) can be the user ID, an email address, GitHub username, a flight ticket number, an invoice ID, or any other identifier that helps to uniquely identify the instance and for whom it is acting on behalf of. Note An instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent. This allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store. If the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off. Agent class API Writing an Agent requires you to define a class that extends the Agent class from the Agents SDK package. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, and any error handling. You can also define your own methods on an Agent: it's technically valid to publish an Agent only has your own methods exposed, and create/get Agents directly from a Worker. Your own methods can access the Agent's environment variables and bindings on this.env , state on this.setState , and call other methods on the Agent via this.yourMethodName . JavaScript TypeScript JavaScript import { Agent } from \"agents\" ; // Pass the Env as a TypeScript type argument // Any services connected to your Agent or Worker as Bindings // are then available on this.env.&#x3C;BINDING_NAME> // The core class for creating Agents that can maintain state, orchestrate // complex AI workflows, schedule tasks, and interact with users and other // Agents. class MyAgent extends Agent { // Optional initial state definition initialState = { counter : 0 , messages : [] , lastUpdated : null , }; // Called when a new Agent instance starts or wakes from hibernation async onStart () { console . log ( \"Agent started with state:\" , this . state ) ; } // Handle HTTP requests coming to this Agent instance // Returns a Response object async onRequest ( request ) { return new Response ( \"Hello from Agent!\" ) ; } // Called when a WebSocket connection is established // Access the original request via ctx.request for auth etc. async onConnect ( connection , ctx ) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } // Called for each message received on a WebSocket connection // Message can be string, ArrayBuffer, or ArrayBufferView async onMessage ( connection , message ) { // Handle incoming messages connection . send ( \"Received your message\" ) ; } // Handle WebSocket connection errors async onError ( connection , error ) { console . error ( `Connection error:` , error ) ; } // Handle WebSocket connection close events async onClose ( connection , code , reason , wasClean ) { console . log ( `Connection closed: ${ code } - ${ reason } ` ) ; } // Called when the Agent's state is updated from any source // source can be \"server\" or a client Connection onStateUpdate ( state , source ) { console . log ( \"State updated:\" , state , \"Source:\" , source ) ; } // You can define your own custom methods to be called by requests, // WebSocket messages, or scheduled tasks async customProcessingMethod ( data ) { // Process data, update state, schedule tasks, etc. this . setState ( { ... this . state , lastUpdated : new Date () } ) ; } } // The core class for creating Agents that can maintain state, orchestrate// complex AI workflows, schedule tasks, and interact with users and other// Agents.class MyAgent extends Agent { // Optional initial state definition initialState = { counter: 0, messages: [], lastUpdated: null, }; // Called when a new Agent instance starts or wakes from hibernation async onStart() { console.log(&#x22;Agent started with state:&#x22;, this.state); } // Handle HTTP requests coming to this Agent instance // Returns a Response object async onRequest(request) { return new Response(&#x22;Hello from Agent!&#x22;); } // Called when a WebSocket connection is established // Access the original request via ctx.request for auth etc. async onConnect(connection, ctx) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } // Called for each message received on a WebSocket connection // Message can be string, ArrayBuffer, or ArrayBufferView async onMessage(connection, message) { // Handle incoming messages connection.send(&#x22;Received your message&#x22;); } // Handle WebSocket connection errors async onError(connection, error) { console.error(&#x60;Connection error:&#x60;, error); } // Handle WebSocket connection close events async onClose(connection, code, reason, wasClean) { console.log(&#x60;Connection closed: ${code} - ${reason}&#x60;); } // Called when the Agent&#x27;s state is updated from any source // source can be &#x22;server&#x22; or a client Connection onStateUpdate(state, source) { console.log(&#x22;State updated:&#x22;, state, &#x22;Source:&#x22;, source); } // You can define your own custom methods to be called by requests, // WebSocket messages, or scheduled tasks async customProcessingMethod(data) { // Process data, update state, schedule tasks, etc. this.setState({ ...this.state, lastUpdated: new Date() }); }}\"> TypeScript import { Agent } from \"agents\" ; interface Env { // Define environment variables &#x26; bindings here } // Pass the Env as a TypeScript type argument // Any services connected to your Agent or Worker as Bindings // are then available on this.env.&#x3C;BINDING_NAME> // The core class for creating Agents that can maintain state, orchestrate // complex AI workflows, schedule tasks, and interact with users and other // Agents. class MyAgent extends Agent &#x3C; Env , State > { // Optional initial state definition initialState = { counter : 0 , messages : [] , lastUpdated : null }; // Called when a new Agent instance starts or wakes from hibernation async onStart () { console . log ( 'Agent started with state:' , this . state ) ; } // Handle HTTP requests coming to this Agent instance // Returns a Response object async onRequest ( request : Request ) : Promise &#x3C; Response > { return new Response ( \"Hello from Agent!\" ) ; } // Called when a WebSocket connection is established // Access the original request via ctx.request for auth etc. async onConnect ( connection : Connection , ctx : ConnectionContext ) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } // Called for each message received on a WebSocket connection // Message can be string, ArrayBuffer, or ArrayBufferView async onMessage ( connection : Connection , message : WSMessage ) { // Handle incoming messages connection . send ( \"Received your message\" ) ; } // Handle WebSocket connection errors async onError ( connection : Connection , error : unknown ) : Promise &#x3C; void > { console . error ( `Connection error:` , error ) ; } // Handle WebSocket connection close events async onClose ( connection : Connection , code : number , reason : string , wasClean : boolean ) : Promise &#x3C; void > { console . log ( `Connection closed: ${ code } - ${ reason } ` ) ; } // Called when the Agent's state is updated from any source // source can be \"server\" or a client Connection onStateUpdate ( state : State , source : \"server\" | Connection ) { console . log ( \"State updated:\" , state , \"Source:\" , source ) ; } // You can define your own custom methods to be called by requests, // WebSocket messages, or scheduled tasks async customProcessingMethod ( data : any ) { // Process data, update state, schedule tasks, etc. this . setState ( { ... this . state , lastUpdated : new Date () } ) ; } } // The core class for creating Agents that can maintain state, orchestrate// complex AI workflows, schedule tasks, and interact with users and other// Agents.class MyAgent extends Agent { // Optional initial state definition initialState = { counter: 0, messages: [], lastUpdated: null }; // Called when a new Agent instance starts or wakes from hibernation async onStart() { console.log(&#x27;Agent started with state:&#x27;, this.state); } // Handle HTTP requests coming to this Agent instance // Returns a Response object async onRequest(request: Request): Promise { return new Response(&#x22;Hello from Agent!&#x22;); } // Called when a WebSocket connection is established // Access the original request via ctx.request for auth etc. async onConnect(connection: Connection, ctx: ConnectionContext) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } // Called for each message received on a WebSocket connection // Message can be string, ArrayBuffer, or ArrayBufferView async onMessage(connection: Connection, message: WSMessage) { // Handle incoming messages connection.send(&#x22;Received your message&#x22;); } // Handle WebSocket connection errors async onError(connection: Connection, error: unknown): Promise { console.error(&#x60;Connection error:&#x60;, error); } // Handle WebSocket connection close events async onClose(connection: Connection, code: number, reason: string, wasClean: boolean): Promise { console.log(&#x60;Connection closed: ${code} - ${reason}&#x60;); } // Called when the Agent&#x27;s state is updated from any source // source can be &#x22;server&#x22; or a client Connection onStateUpdate(state: State, source: &#x22;server&#x22; | Connection) { console.log(&#x22;State updated:&#x22;, state, &#x22;Source:&#x22;, source); } // You can define your own custom methods to be called by requests, // WebSocket messages, or scheduled tasks async customProcessingMethod(data: any) { // Process data, update state, schedule tasks, etc. this.setState({ ...this.state, lastUpdated: new Date() }); }}\"> JavaScript TypeScript JavaScript // Basic Agent implementation with custom methods import { Agent } from \"agents\" ; class MyAgent extends Agent { initialState = { counter : 0 , lastUpdated : null , }; async onRequest ( request ) { if ( request . method === \"POST\" ) { await this . incrementCounter () ; return new Response ( JSON . stringify ( this . state ) , { headers : { \"Content-Type\" : \"application/json\" }, } ) ; } return new Response ( JSON . stringify ( this . state ) , { headers : { \"Content-Type\" : \"application/json\" }, } ) ; } async incrementCounter () { this . setState ( { counter : this . state . counter + 1 , lastUpdated : new Date () , } ) ; } } TypeScript // Basic Agent implementation with custom methods import { Agent } from \"agents\" ; interface MyState { counter : number ; lastUpdated : Date | null ; } class MyAgent extends Agent &#x3C; Env , MyState > { initialState = { counter : 0 , lastUpdated : null }; async onRequest ( request : Request ) { if ( request . method === \"POST\" ) { await this . incrementCounter () ; return new Response ( JSON . stringify ( this . state ) , { headers : { \"Content-Type\" : \"application/json\" } } ) ; } return new Response ( JSON . stringify ( this . state ) , { headers : { \"Content-Type\" : \"application/json\" } } ) ; } async incrementCounter () { this . setState ( { counter : this . state . counter + 1 , lastUpdated : new Date () } ) ; } } { initialState = { counter: 0, lastUpdated: null }; async onRequest(request: Request) { if (request.method === &#x22;POST&#x22;) { await this.incrementCounter(); return new Response(JSON.stringify(this.state), { headers: { &#x22;Content-Type&#x22;: &#x22;application/json&#x22; } }); } return new Response(JSON.stringify(this.state), { headers: { &#x22;Content-Type&#x22;: &#x22;application/json&#x22; } }); } async incrementCounter() { this.setState({ counter: this.state.counter + 1, lastUpdated: new Date() }); }}\"> WebSocket API The WebSocket API allows you to accept and manage WebSocket connections made to an Agent. Connection Represents a WebSocket connection to an Agent. TypeScript // WebSocket connection interface interface Connection &#x3C; State = unknown > { // Unique ID for this connection id : string ; // Client-specific state attached to this connection state : State ; // Update the connection's state setState ( state : State ) : void ; // Accept an incoming WebSocket connection accept () : void ; // Close the WebSocket connection with optional code and reason close ( code ?: number , reason ?: string ) : void ; // Send a message to the client // Can be string, ArrayBuffer, or ArrayBufferView send ( message : string | ArrayBuffer | ArrayBufferView ) : void ; } { // Unique ID for this connection id: string; // Client-specific state attached to this connection state: State; // Update the connection&#x27;s state setState(state: State): void; // Accept an incoming WebSocket connection accept(): void; // Close the WebSocket connection with optional code and reason close(code?: number, reason?: string): void; // Send a message to the client // Can be string, ArrayBuffer, or ArrayBufferView send(message: string | ArrayBuffer | ArrayBufferView): void;}\"> JavaScript TypeScript JavaScript // Example of handling WebSocket messages export class YourAgent extends Agent { async onMessage ( connection , message ) { if ( typeof message === \"string\" ) { try { // Parse JSON message const data = JSON . parse ( message ) ; if ( data . type === \"update\" ) { // Update connection-specific state connection . setState ( { ... connection . state , lastActive : Date . now () } ) ; // Update global Agent state this . setState ( { ... this . state , connections : this . state . connections + 1 , } ) ; // Send response back to this client only connection . send ( JSON . stringify ( { type : \"updated\" , status : \"success\" , } ) , ) ; } } catch ( e ) { connection . send ( JSON . stringify ( { error : \"Invalid message format\" } )) ; } } } } TypeScript // Example of handling WebSocket messages export class YourAgent extends Agent { async onMessage ( connection : Connection , message : WSMessage ) { if ( typeof message === 'string' ) { try { // Parse JSON message const data = JSON . parse ( message ) ; if ( data . type === 'update' ) { // Update connection-specific state connection . setState ( { ... connection . state , lastActive : Date . now () } ) ; // Update global Agent state this . setState ( { ... this . state , connections : this . state . connections + 1 } ) ; // Send response back to this client only connection . send ( JSON . stringify ( { type : 'updated' , status : 'success' } )) ; } } catch ( e ) { connection . send ( JSON . stringify ( { error : 'Invalid message format' } )) ; } } } } WSMessage Types of messages that can be received from a WebSocket. TypeScript // Types of messages that can be received from WebSockets type WSMessage = string | ArrayBuffer | ArrayBufferView ; ConnectionContext Context information for a WebSocket connection. TypeScript // Context available during WebSocket connection interface ConnectionContext { // The original HTTP request that initiated the WebSocket connection request : Request ; } State synchronization API Note To learn more about how to manage state within an Agent, refer to the documentation on managing and syncing state . State Methods and types for managing Agent state. TypeScript // State management in the Agent class class Agent &#x3C; Env , State = unknown > { // Initial state that will be set if no state exists yet initialState : State = {} as unknown as State ; // Current state of the Agent, persisted across restarts get state () : State ; // Update the Agent's state // Persists to storage and notifies all connected clients setState ( state : State ) : void ; // Called when state is updated from any source // Override to react to state changes onStateUpdate ( state : State , source : \"server\" | Connection ) : void ; } { // Initial state that will be set if no state exists yet initialState: State = {} as unknown as State; // Current state of the Agent, persisted across restarts get state(): State; // Update the Agent&#x27;s state // Persists to storage and notifies all connected clients setState(state: State): void; // Called when state is updated from any source // Override to react to state changes onStateUpdate(state: State, source: &#x22;server&#x22; | Connection): void;}\"> JavaScript TypeScript JavaScript // Example of state management in an Agent // Inside your Agent class export class YourAgent extends Agent { async addMessage ( sender , text ) { // Update state with new message this . setState ( { ... this . state , messages : [ ... this . state . messages , { sender , text , timestamp : Date . now () }, ] . slice ( - this . state . settings . maxHistoryLength ) , // Maintain max history } ) ; // The onStateUpdate method will automatically be called // and all connected clients will receive the update } // Override onStateUpdate to add custom behavior when state changes onStateUpdate ( state , source ) { console . log ( `State updated by ${ source === \"server\" ? \"server\" : \"client\" } ` , ) ; // You could trigger additional actions based on state changes if ( state . messages . length > 0 ) { const lastMessage = state . messages [ state . messages . length - 1 ] ; if ( lastMessage . text . includes ( \"@everyone\" )) { this . notifyAllParticipants ( lastMessage ) ; } } } } 0) { const lastMessage = state.messages[state.messages.length - 1]; if (lastMessage.text.includes(&#x22;@everyone&#x22;)) { this.notifyAllParticipants(lastMessage); } } }}\"> TypeScript // Example of state management in an Agent interface ChatState { messages : Array &#x3C;{ sender : string ; text : string ; timestamp : number }>; participants : string [] ; settings : { allowAnonymous : boolean ; maxHistoryLength : number ; }; } interface Env { // Your bindings and environment variables } // Inside your Agent class export class YourAgent extends Agent &#x3C; Env , ChatState > { async addMessage ( sender : string , text : string ) { // Update state with new message this . setState ( { ... this . state , messages : [ ... this . state . messages , { sender , text , timestamp : Date . now () } ] . slice ( - this . state . settings . maxHistoryLength ) // Maintain max history } ) ; // The onStateUpdate method will automatically be called // and all connected clients will receive the update } // Override onStateUpdate to add custom behavior when state changes onStateUpdate ( state : ChatState , source : \"server\" | Connection ) { console . log ( `State updated by ${ source === \"server\" ? \"server\" : \"client\" } ` ) ; // You could trigger additional actions based on state changes if ( state . messages . length > 0 ) { const lastMessage = state . messages [ state . messages . length - 1 ] ; if ( lastMessage . text . includes ( '@everyone' )) { this . notifyAllParticipants ( lastMessage ) ; } } } } ; participants: string[]; settings: { allowAnonymous: boolean; maxHistoryLength: number; };}interface Env { // Your bindings and environment variables}// Inside your Agent classexport class YourAgent extends Agent { async addMessage(sender: string, text: string) { // Update state with new message this.setState({ ...this.state, messages: [ ...this.state.messages, { sender, text, timestamp: Date.now() } ].slice(-this.state.settings.maxHistoryLength) // Maintain max history }); // The onStateUpdate method will automatically be called // and all connected clients will receive the update } // Override onStateUpdate to add custom behavior when state changes onStateUpdate(state: ChatState, source: &#x22;server&#x22; | Connection) { console.log(&#x60;State updated by ${source === &#x22;server&#x22; ? &#x22;server&#x22; : &#x22;client&#x22;}&#x60;); // You could trigger additional actions based on state changes if (state.messages.length > 0) { const lastMessage = state.messages[state.messages.length - 1]; if (lastMessage.text.includes(&#x27;@everyone&#x27;)) { this.notifyAllParticipants(lastMessage); } } }}\"> Scheduling API Scheduling tasks Schedule tasks to run at a specified time in the future. TypeScript // Scheduling API for running tasks in the future class Agent &#x3C; Env , State = unknown > { // Schedule a task to run in the future // when: seconds from now, specific Date, or cron expression // callback: method name on the Agent to call // payload: data to pass to the callback // Returns a Schedule object with the task ID async schedule &#x3C; T = any >( when : Date | string | number , callback : keyof this , payload ?: T ) : Promise &#x3C; Schedule &#x3C; T >>; // Get a scheduled task by ID // Returns undefined if the task doesn't exist async getSchedule &#x3C; T = any >( id : string ) : Promise &#x3C; Schedule &#x3C; T > | undefined >; // Get all scheduled tasks matching the criteria // Returns an array of Schedule objects getSchedules &#x3C; T = any >( criteria ?: { description ?: string ; id ?: string ; type ?: \"scheduled\" | \"delayed\" | \"cron\" ; timeRange ?: { start ?: Date ; end ?: Date }; }) : Schedule &#x3C; T > [] ; // Cancel a scheduled task by ID // Returns true if the task was cancelled, false otherwise async cancelSchedule ( id : string ) : Promise &#x3C; boolean >; } { // Schedule a task to run in the future // when: seconds from now, specific Date, or cron expression // callback: method name on the Agent to call // payload: data to pass to the callback // Returns a Schedule object with the task ID async schedule ( when: Date | string | number, callback: keyof this, payload?: T ): Promise >; // Get a scheduled task by ID // Returns undefined if the task doesn&#x27;t exist async getSchedule (id: string): Promise | undefined>; // Get all scheduled tasks matching the criteria // Returns an array of Schedule objects getSchedules (criteria?: { description?: string; id?: string; type?: &#x22;scheduled&#x22; | &#x22;delayed&#x22; | &#x22;cron&#x22;; timeRange?: { start?: Date; end?: Date }; }): Schedule []; // Cancel a scheduled task by ID // Returns true if the task was cancelled, false otherwise async cancelSchedule(id: string): Promise ;}\"> JavaScript TypeScript JavaScript // Example of scheduling in an Agent export class YourAgent extends Agent { // Schedule a one-time reminder in 2 hours async scheduleReminder ( userId , message ) { const twoHoursFromNow = new Date ( Date . now () + 2 * 60 * 60 * 1000 ) ; const schedule = await this . schedule ( twoHoursFromNow , \"sendReminder\" , { userId , message , channel : \"email\" , } ) ; console . log ( `Scheduled reminder with ID: ${ schedule . id } ` ) ; return schedule . id ; } // Schedule a recurring daily task using cron async scheduleDailyReport () { // Run at 08:00 AM every day const schedule = await this . schedule ( \"0 8 * * *\" , // Cron expression: minute hour day month weekday \"generateDailyReport\" , { reportType : \"daily-summary\" }, ) ; console . log ( `Scheduled daily report with ID: ${ schedule . id } ` ) ; return schedule . id ; } // Method that will be called when the scheduled task runs async sendReminder ( data ) { console . log ( `Sending reminder to ${ data . userId } : ${ data . message } ` ) ; // Add code to send the actual notification } } TypeScript // Example of scheduling in an Agent interface ReminderData { userId : string ; message : string ; channel : string ; } export class YourAgent extends Agent { // Schedule a one-time reminder in 2 hours async scheduleReminder ( userId : string , message : string ) { const twoHoursFromNow = new Date ( Date . now () + 2 * 60 * 60 * 1000 ) ; const schedule = await this . schedule &#x3C; ReminderData > ( twoHoursFromNow , 'sendReminder' , { userId , message , channel : 'email' } ) ; console . log ( `Scheduled reminder with ID: ${ schedule . id } ` ) ; return schedule . id ; } // Schedule a recurring daily task using cron async scheduleDailyReport () { // Run at 08:00 AM every day const schedule = await this . schedule ( '0 8 * * *' , // Cron expression: minute hour day month weekday 'generateDailyReport' , { reportType : 'daily-summary' } ) ; console . log ( `Scheduled daily report with ID: ${ schedule . id } ` ) ; return schedule . id ; } // Method that will be called when the scheduled task runs async sendReminder ( data : ReminderData ) { console . log ( `Sending reminder to ${ data . userId } : ${ data . message } ` ) ; // Add code to send the actual notification } } ( twoHoursFromNow, &#x27;sendReminder&#x27;, { userId, message, channel: &#x27;email&#x27; } ); console.log(&#x60;Scheduled reminder with ID: ${schedule.id}&#x60;); return schedule.id; } // Schedule a recurring daily task using cron async scheduleDailyReport() { // Run at 08:00 AM every day const schedule = await this.schedule( &#x27;0 8 * * *&#x27;, // Cron expression: minute hour day month weekday &#x27;generateDailyReport&#x27;, { reportType: &#x27;daily-summary&#x27; } ); console.log(&#x60;Scheduled daily report with ID: ${schedule.id}&#x60;); return schedule.id; } // Method that will be called when the scheduled task runs async sendReminder(data: ReminderData) { console.log(&#x60;Sending reminder to ${data.userId}: ${data.message}&#x60;); // Add code to send the actual notification }}\"> Schedule object Represents a scheduled task. TypeScript // Represents a scheduled task type Schedule &#x3C; T = any > = { // Unique identifier for the schedule id : string ; // Name of the method to be called callback : string ; // Data to be passed to the callback payload : T ; } &#x26; ( | { // One-time execution at a specific time type : \"scheduled\" ; // Timestamp when the task should execute time : number ; } | { // Delayed execution after a certain time type : \"delayed\" ; // Timestamp when the task should execute time : number ; // Number of seconds to delay execution delayInSeconds : number ; } | { // Recurring execution based on cron expression type : \"cron\" ; // Timestamp for the next execution time : number ; // Cron expression defining the schedule cron : string ; } ) ; = { // Unique identifier for the schedule id: string; // Name of the method to be called callback: string; // Data to be passed to the callback payload: T;} &#x26; ( | { // One-time execution at a specific time type: &#x22;scheduled&#x22;; // Timestamp when the task should execute time: number; } | { // Delayed execution after a certain time type: &#x22;delayed&#x22;; // Timestamp when the task should execute time: number; // Number of seconds to delay execution delayInSeconds: number; } | { // Recurring execution based on cron expression type: &#x22;cron&#x22;; // Timestamp for the next execution time: number; // Cron expression defining the schedule cron: string; });\"> JavaScript TypeScript JavaScript export class YourAgent extends Agent { // Example of managing scheduled tasks async viewAndManageSchedules () { // Get all scheduled tasks const allSchedules = this . getSchedules () ; console . log ( `Total scheduled tasks: ${ allSchedules . length } ` ) ; // Get tasks scheduled for a specific time range const upcomingSchedules = this . getSchedules ( { timeRange : { start : new Date () , end : new Date ( Date . now () + 24 * 60 * 60 * 1000 ) , // Next 24 hours }, } ) ; // Get a specific task by ID const taskId = \"task-123\" ; const specificTask = await this . getSchedule ( taskId ) ; if ( specificTask ) { console . log ( `Found task: ${ specificTask . callback } at ${ new Date ( specificTask . time ) } ` , ) ; // Cancel a scheduled task const cancelled = await this . cancelSchedule ( taskId ) ; console . log ( `Task cancelled: ${ cancelled } ` ) ; } } } TypeScript export class YourAgent extends Agent { // Example of managing scheduled tasks async viewAndManageSchedules () { // Get all scheduled tasks const allSchedules = this . getSchedules () ; console . log ( `Total scheduled tasks: ${ allSchedules . length } ` ) ; // Get tasks scheduled for a specific time range const upcomingSchedules = this . getSchedules ( { timeRange : { start : new Date () , end : new Date ( Date . now () + 24 * 60 * 60 * 1000 ) // Next 24 hours } } ) ; // Get a specific task by ID const taskId = \"task-123\" ; const specificTask = await this . getSchedule ( taskId ) ; if ( specificTask ) { console . log ( `Found task: ${ specificTask . callback } at ${ new Date ( specificTask . time ) } ` ) ; // Cancel a scheduled task const cancelled = await this . cancelSchedule ( taskId ) ; console . log ( `Task cancelled: ${ cancelled } ` ) ; } } } SQL API Each Agent instance has an embedded SQLite database that can be accessed using the this.sql method within any method on your Agent class. SQL queries Execute SQL queries against the Agent's built-in SQLite database using the this.sql method within any method on your Agent class. TypeScript // SQL query API for the Agent's embedded database class Agent &#x3C; Env , State = unknown > { // Execute a SQL query with tagged template literals // Returns an array of rows matching the query sql &#x3C; T = Record &#x3C; string , string | number | boolean | null >>( strings : TemplateStringsArray , ... values : ( string | number | boolean | null )[] ) : T [] ; } { // Execute a SQL query with tagged template literals // Returns an array of rows matching the query sql >( strings: TemplateStringsArray, ...values: (string | number | boolean | null)[] ): T[];}\"> JavaScript TypeScript JavaScript // Example of using SQL in an Agent export class YourAgent extends Agent { async setupDatabase () { // Create a table if it doesn't exist this . sql ` CREATE TABLE IF NOT EXISTS users ( id TEXT PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE, created_at INTEGER ) ` ; } async createUser ( id , name , email ) { // Insert a new user this . sql ` INSERT INTO users (id, name, email, created_at) VALUES ( ${ id } , ${ name } , ${ email } , ${ Date . now () } ) ` ; } async getUserById ( id ) { // Query a user by ID const users = this . sql ` SELECT * FROM users WHERE id = ${ id } ` ; return users . length ? users [ 0 ] : null ; } async searchUsers ( term ) { // Search users with a wildcard return this . sql ` SELECT * FROM users WHERE name LIKE ${ \"%\" + term + \"%\" } OR email LIKE ${ \"%\" + term + \"%\" } ORDER BY created_at DESC ` ; } } TypeScript // Example of using SQL in an Agent interface User { id : string ; name : string ; email : string ; created_at : number ; } export class YourAgent extends Agent { async setupDatabase () { // Create a table if it doesn't exist this . sql ` CREATE TABLE IF NOT EXISTS users ( id TEXT PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE, created_at INTEGER ) ` ; } async createUser ( id : string , name : string , email : string ) { // Insert a new user this . sql ` INSERT INTO users (id, name, email, created_at) VALUES ( ${ id } , ${ name } , ${ email } , ${ Date . now () } ) ` ; } async getUserById ( id : string ) : Promise &#x3C; User | null > { // Query a user by ID const users = this . sql &#x3C; User > ` SELECT * FROM users WHERE id = ${ id } ` ; return users . length ? users [ 0 ] : null ; } async searchUsers ( term : string ) : Promise &#x3C; User [] > { // Search users with a wildcard return this . sql &#x3C; User > ` SELECT * FROM users WHERE name LIKE ${ '%' + term + '%' } OR email LIKE ${ '%' + term + '%' } ORDER BY created_at DESC ` ; } } { // Query a user by ID const users = this.sql &#x60; SELECT * FROM users WHERE id = ${id} &#x60;; return users.length ? users[0] : null; } async searchUsers(term: string): Promise { // Search users with a wildcard return this.sql &#x60; SELECT * FROM users WHERE name LIKE ${&#x27;%&#x27; + term + &#x27;%&#x27;} OR email LIKE ${&#x27;%&#x27; + term + &#x27;%&#x27;} ORDER BY created_at DESC &#x60;; }}\"> Note Visit the state management API documentation within the Agents SDK, including the native state APIs and the built-in this.sql API for storing and querying data within your Agents. MCP Client API The Agents SDK allows your Agent to act as an MCP (Model Context Protocol) client, connecting to remote MCP servers and using their tools, resources, and prompts. JavaScript TypeScript JavaScript class Agent { // Connect to an MCP server // Disconnect from an MCP server // Get state of all connected MCP servers } TypeScript class Agent &#x3C; Env , State = unknown > { // Connect to an MCP server async addMcpServer ( serverName : string , url : string , callbackHost ?: string , agentsPrefix ?: string , options ?: MCPClientOptions ) : Promise &#x3C;{ id : string ; authUrl : string | undefined }>; // Disconnect from an MCP server async removeMcpServer ( id : string ) : Promise &#x3C; void >; // Get state of all connected MCP servers getMcpServers () : MCPServersState ; } { // Connect to an MCP server async addMcpServer( serverName: string, url: string, callbackHost?: string, agentsPrefix?: string, options?: MCPClientOptions ): Promise ; // Disconnect from an MCP server async removeMcpServer(id: string): Promise ; // Get state of all connected MCP servers getMcpServers(): MCPServersState;}\"> When your Agent connects to MCP servers, it can dynamically discover and use tools provided by those servers, enabling powerful integrations with external services. Note For complete MCP client API documentation, including OAuth configuration and advanced usage, refer to the Agent — MCP Client API . Client API The Agents SDK provides a set of client APIs for interacting with Agents from client-side JavaScript code, including: React hooks, including useAgent and useAgentChat , for connecting to Agents from client applications. Client-side state syncing that allows you to subscribe to state updates between the Agent and any connected client(s) when calling this.setState within your Agent's code. The ability to call remote methods (Remote Procedure Calls; RPC) on the Agent from client-side JavaScript code using the @callable method decorator. AgentClient Client for connecting to an Agent from the browser. TypeScript import { AgentClient } from \"agents/client\" ; // Options for creating an AgentClient type AgentClientOptions = Omit &#x3C; PartySocketOptions , \"party\" | \"room\" > &#x26; { // Name of the agent to connect to (class name in kebab-case) agent : string ; // Name of the specific Agent instance (optional, defaults to \"default\") name ?: string ; // Other WebSocket options like host, protocol, etc. }; // WebSocket client for connecting to an Agent class AgentClient extends PartySocket { static fetch ( opts : PartyFetchOptions ) : Promise &#x3C; Response >; constructor ( opts : AgentClientOptions ); } &#x26; { // Name of the agent to connect to (class name in kebab-case) agent: string; // Name of the specific Agent instance (optional, defaults to &#x22;default&#x22;) name?: string; // Other WebSocket options like host, protocol, etc.};// WebSocket client for connecting to an Agentclass AgentClient extends PartySocket { static fetch(opts: PartyFetchOptions): Promise ; constructor(opts: AgentClientOptions);}\"> JavaScript TypeScript JavaScript // Example of using AgentClient in the browser import { AgentClient } from \"agents/client\" ; // Connect to an Agent instance const client = new AgentClient ( { agent : \"chat-agent\" , // Name of your Agent class in kebab-case name : \"support-room-123\" , // Specific instance name host : window . location . host , // Using same host } ) ; client . onopen = () => { console . log ( \"Connected to agent\" ) ; // Send an initial message client . send ( JSON . stringify ( { type : \"join\" , user : \"user123\" } )) ; }; client . onmessage = ( event ) => { // Handle incoming messages const data = JSON . parse ( event . data ) ; console . log ( \"Received:\" , data ) ; if ( data . type === \"state_update\" ) { // Update local UI with new state updateUI ( data . state ) ; } }; client . onclose = () => console . log ( \"Disconnected from agent\" ) ; // Send messages to the Agent function sendMessage ( text ) { client . send ( JSON . stringify ( { type : \"message\" , text , timestamp : Date . now () , } ) , ) ; } { console.log(&#x22;Connected to agent&#x22;); // Send an initial message client.send(JSON.stringify({ type: &#x22;join&#x22;, user: &#x22;user123&#x22; }));};client.onmessage = (event) => { // Handle incoming messages const data = JSON.parse(event.data); console.log(&#x22;Received:&#x22;, data); if (data.type === &#x22;state_update&#x22;) { // Update local UI with new state updateUI(data.state); }};client.onclose = () => console.log(&#x22;Disconnected from agent&#x22;);// Send messages to the Agentfunction sendMessage(text) { client.send( JSON.stringify({ type: &#x22;message&#x22;, text, timestamp: Date.now(), }), );}\"> TypeScript // Example of using AgentClient in the browser import { AgentClient } from \"agents/client\" ; // Connect to an Agent instance const client = new AgentClient ( { agent : \"chat-agent\" , // Name of your Agent class in kebab-case name : \"support-room-123\" , // Specific instance name host : window . location . host , // Using same host } ) ; client . onopen = () => { console . log ( \"Connected to agent\" ) ; // Send an initial message client . send ( JSON . stringify ( { type : \"join\" , user : \"user123\" } )) ; }; client . onmessage = ( event ) => { // Handle incoming messages const data = JSON . parse ( event . data ) ; console . log ( \"Received:\" , data ) ; if ( data . type === \"state_update\" ) { // Update local UI with new state updateUI ( data . state ) ; } }; client . onclose = () => console . log ( \"Disconnected from agent\" ) ; // Send messages to the Agent function sendMessage ( text ) { client . send ( JSON . stringify ( { type : \"message\" , text , timestamp : Date . now () } )) ; } { console.log(&#x22;Connected to agent&#x22;); // Send an initial message client.send(JSON.stringify({ type: &#x22;join&#x22;, user: &#x22;user123&#x22; }));};client.onmessage = (event) => { // Handle incoming messages const data = JSON.parse(event.data); console.log(&#x22;Received:&#x22;, data); if (data.type === &#x22;state_update&#x22;) { // Update local UI with new state updateUI(data.state); }};client.onclose = () => console.log(&#x22;Disconnected from agent&#x22;);// Send messages to the Agentfunction sendMessage(text) { client.send(JSON.stringify({ type: &#x22;message&#x22;, text, timestamp: Date.now() }));}\"> agentFetch Make an HTTP request to an Agent. TypeScript import { agentFetch } from \"agents/client\" ; // Options for the agentFetch function type AgentClientFetchOptions = Omit &#x3C; PartyFetchOptions , \"party\" | \"room\" > &#x26; { // Name of the agent to connect to agent : string ; // Name of the specific Agent instance (optional) name ?: string ; }; // Make an HTTP request to an Agent function agentFetch ( opts : AgentClientFetchOptions , init ?: RequestInit ) : Promise &#x3C; Response >; &#x26; { // Name of the agent to connect to agent: string; // Name of the specific Agent instance (optional) name?: string;};// Make an HTTP request to an Agentfunction agentFetch( opts: AgentClientFetchOptions, init?: RequestInit): Promise ;\"> JavaScript TypeScript JavaScript // Example of using agentFetch in the browser import { agentFetch } from \"agents/client\" ; // Function to get data from an Agent async function fetchAgentData () { try { const response = await agentFetch ( { agent : \"task-manager\" , name : \"user-123-tasks\" , }, { method : \"GET\" , headers : { Authorization : `Bearer ${ userToken } ` , }, }, ) ; if ( ! response . ok ) { throw new Error ( `Error: ${ response . status } ` ) ; } const data = await response . json () ; return data ; } catch ( error ) { console . error ( \"Failed to fetch from agent:\" , error ) ; } } TypeScript // Example of using agentFetch in the browser import { agentFetch } from \"agents/client\" ; // Function to get data from an Agent async function fetchAgentData () { try { const response = await agentFetch ( { agent : \"task-manager\" , name : \"user-123-tasks\" }, { method : \"GET\" , headers : { \"Authorization\" : `Bearer ${ userToken } ` } } ) ; if ( ! response . ok ) { throw new Error ( `Error: ${ response . status } ` ) ; } const data = await response . json () ; return data ; } catch ( error ) { console . error ( \"Failed to fetch from agent:\" , error ) ; } } React API The Agents SDK provides a React API for simplifying connection and routing to Agents from front-end frameworks, including React Router (Remix), Next.js, and Astro. useAgent React hook for connecting to an Agent. TypeScript import { useAgent } from \"agents/react\" ; // Options for the useAgent hook type UseAgentOptions &#x3C; State = unknown > = Omit &#x3C; Parameters &#x3C; typeof usePartySocket > [ 0 ] , \"party\" | \"room\" > &#x26; { // Name of the agent to connect to agent : string ; // Name of the specific Agent instance (optional) name ?: string ; // Called when the Agent's state is updated onStateUpdate ?: ( state : State , source : \"server\" | \"client\" ) => void ; }; // React hook for connecting to an Agent // Returns a WebSocket connection with setState method function useAgent &#x3C; State = unknown >( options : UseAgentOptions &#x3C; State > ) : PartySocket &#x26; { // Update the Agent's state setState : ( state : State ) => void }; = Omit [0], &#x22;party&#x22; | &#x22;room&#x22;> &#x26; { // Name of the agent to connect to agent: string; // Name of the specific Agent instance (optional) name?: string; // Called when the Agent&#x27;s state is updated onStateUpdate?: (state: State, source: &#x22;server&#x22; | &#x22;client&#x22;) => void;};// React hook for connecting to an Agent// Returns a WebSocket connection with setState methodfunction useAgent ( options: UseAgentOptions ): PartySocket &#x26; { // Update the Agent&#x27;s state setState: (state: State) => void};\"> Chat Agent The Agents SDK exposes an AIChatAgent class that extends the Agent class and exposes an onChatMessage method that simplifies building interactive chat agents. You can combine this with the useAgentChat React hook from the agents/ai-react package to manage chat state and messages between a user and your Agent(s). AIChatAgent Extension of the Agent class with built-in chat capabilities. TypeScript import { AIChatAgent } from \"agents/ai-chat-agent\" ; import { Message , StreamTextOnFinishCallback , ToolSet } from \"ai\" ; // Base class for chat-specific agents class AIChatAgent &#x3C; Env = unknown , State = unknown > extends Agent &#x3C; Env , State > { // Array of chat messages for the current conversation messages : Message [] ; // Handle incoming chat messages and generate a response // onFinish is called when the response is complete async onChatMessage ( onFinish : StreamTextOnFinishCallback &#x3C; ToolSet > ) : Promise &#x3C; Response | undefined >; // Persist messages within the Agent's local storage. async saveMessages ( messages : Message [] ) : Promise &#x3C; void >; } extends Agent { // Array of chat messages for the current conversation messages: Message[]; // Handle incoming chat messages and generate a response // onFinish is called when the response is complete async onChatMessage( onFinish: StreamTextOnFinishCallback  ): Promise ; // Persist messages within the Agent&#x27;s local storage. async saveMessages(messages: Message[]): Promise ;}\"> JavaScript TypeScript JavaScript // Example of extending AIChatAgent import { AIChatAgent } from \"agents/ai-chat-agent\" ; import { Message } from \"ai\" ; class CustomerSupportAgent extends AIChatAgent { // Override the onChatMessage method to customize behavior async onChatMessage ( onFinish ) { // Access the AI models using environment bindings const { openai } = this . env . AI ; // Get the current conversation history const chatHistory = this . messages ; // Generate a system prompt based on knowledge base const systemPrompt = await this . generateSystemPrompt () ; // Generate a response stream const stream = await openai . chat ( { model : \"gpt-4o\" , messages : [ { role : \"system\" , content : systemPrompt }, ... chatHistory ] , stream : true , } ) ; // Return the streaming response return new Response ( stream , { headers : { \"Content-Type\" : \"text/event-stream\" }, } ) ; } // Helper method to generate a system prompt async generateSystemPrompt () { // Query knowledge base or use static prompt return `You are a helpful customer support agent. Respond to customer inquiries based on the following guidelines: - Be friendly and professional - If you don't know an answer, say so - Current company policies: ...` ; } } TypeScript // Example of extending AIChatAgent import { AIChatAgent } from \"agents/ai-chat-agent\" ; import { Message } from \"ai\" ; interface Env { AI : any ; // Your AI binding } class CustomerSupportAgent extends AIChatAgent &#x3C; Env > { // Override the onChatMessage method to customize behavior async onChatMessage ( onFinish ) { // Access the AI models using environment bindings const { openai } = this . env . AI ; // Get the current conversation history const chatHistory = this . messages ; // Generate a system prompt based on knowledge base const systemPrompt = await this . generateSystemPrompt () ; // Generate a response stream const stream = await openai . chat ( { model : \"gpt-4o\" , messages : [ { role : \"system\" , content : systemPrompt }, ... chatHistory ] , stream : true } ) ; // Return the streaming response return new Response ( stream , { headers : { \"Content-Type\" : \"text/event-stream\" } } ) ; } // Helper method to generate a system prompt async generateSystemPrompt () { // Query knowledge base or use static prompt return `You are a helpful customer support agent. Respond to customer inquiries based on the following guidelines: - Be friendly and professional - If you don't know an answer, say so - Current company policies: ...` ; } } { // Override the onChatMessage method to customize behavior async onChatMessage(onFinish) { // Access the AI models using environment bindings const { openai } = this.env.AI; // Get the current conversation history const chatHistory = this.messages; // Generate a system prompt based on knowledge base const systemPrompt = await this.generateSystemPrompt(); // Generate a response stream const stream = await openai.chat({ model: &#x22;gpt-4o&#x22;, messages: [ { role: &#x22;system&#x22;, content: systemPrompt }, ...chatHistory ], stream: true }); // Return the streaming response return new Response(stream, { headers: { &#x22;Content-Type&#x22;: &#x22;text/event-stream&#x22; } }); } // Helper method to generate a system prompt async generateSystemPrompt() { // Query knowledge base or use static prompt return &#x60;You are a helpful customer support agent. Respond to customer inquiries based on the following guidelines: - Be friendly and professional - If you don&#x27;t know an answer, say so - Current company policies: ...&#x60;; }}\"> Chat Agent React API useAgentChat React hook for building AI chat interfaces using an Agent. TypeScript import { useAgentChat } from \"agents/ai-react\" ; import { useAgent } from \"agents/react\" ; import type { Message } from \"ai\" ; // Options for the useAgentChat hook type UseAgentChatOptions = Omit &#x3C; Parameters &#x3C; typeof useChat > [ 0 ] &#x26; { // Agent connection from useAgent agent : ReturnType &#x3C; typeof useAgent >; }, \"fetch\" >; // React hook for building AI chat interfaces using an Agent function useAgentChat ( options : UseAgentChatOptions ) : { // Current chat messages messages : Message [] ; // Set messages and synchronize with the Agent setMessages : ( messages : Message [] ) => void ; // Clear chat history on both client and Agent clearHistory : () => void ; // Append a new message to the conversation append : ( message : Message , chatRequestOptions ?: any ) => Promise &#x3C; string | null | undefined >; // Reload the last user message reload : ( chatRequestOptions ?: any ) => Promise &#x3C; string | null | undefined >; // Stop the AI response generation stop : () => void ; // Current input text input : string ; // Set the input text setInput : React . Dispatch &#x3C; React . SetStateAction &#x3C; string >>; // Handle input changes handleInputChange : ( e : React . ChangeEvent &#x3C; HTMLInputElement | HTMLTextAreaElement >) => void ; // Submit the current input handleSubmit : ( event ?: { preventDefault ?: () => void }, chatRequestOptions ?: any ) => void ; // Additional metadata metadata ?: Object ; // Whether a response is currently being generated isLoading : boolean ; // Current status of the chat status : \"submitted\" | \"streaming\" | \"ready\" | \"error\" ; // Tool data from the AI response data ?: any [] ; // Set tool data setData : ( data : any [] | undefined | ( ( data : any [] | undefined ) => any [] | undefined ) ) => void ; // Unique ID for the chat id : string ; // Add a tool result for a specific tool call addToolResult : ( { toolCallId , result } : { toolCallId : string ; result : any } ) => void ; // Current error if any error : Error | undefined ; }; [0] &#x26; { // Agent connection from useAgent agent: ReturnType ; }, &#x22;fetch&#x22;>;// React hook for building AI chat interfaces using an Agentfunction useAgentChat(options: UseAgentChatOptions): { // Current chat messages messages: Message[]; // Set messages and synchronize with the Agent setMessages: (messages: Message[]) => void; // Clear chat history on both client and Agent clearHistory: () => void; // Append a new message to the conversation append: (message: Message, chatRequestOptions?: any) => Promise ; // Reload the last user message reload: (chatRequestOptions?: any) => Promise ; // Stop the AI response generation stop: () => void; // Current input text input: string; // Set the input text setInput: React.Dispatch >; // Handle input changes handleInputChange: (e: React.ChangeEvent ) => void; // Submit the current input handleSubmit: (event?: { preventDefault?: () => void }, chatRequestOptions?: any) => void; // Additional metadata metadata?: Object; // Whether a response is currently being generated isLoading: boolean; // Current status of the chat status: &#x22;submitted&#x22; | &#x22;streaming&#x22; | &#x22;ready&#x22; | &#x22;error&#x22;; // Tool data from the AI response data?: any[]; // Set tool data setData: (data: any[] | undefined | ((data: any[] | undefined) => any[] | undefined)) => void; // Unique ID for the chat id: string; // Add a tool result for a specific tool call addToolResult: ({ toolCallId, result }: { toolCallId: string; result: any }) => void; // Current error if any error: Error | undefined;};\"> JavaScript TypeScript JavaScript // Example of using useAgentChat in a React component import { useAgentChat } from \"agents/ai-react\" ; import { useAgent } from \"agents/react\" ; import { useState } from \"react\" ; function ChatInterface () { // Connect to the chat agent const agentConnection = useAgent ( { agent : \"customer-support\" , name : \"session-12345\" , } ) ; // Use the useAgentChat hook with the agent connection const { messages , input , handleInputChange , handleSubmit , isLoading , error , clearHistory , } = useAgentChat ( { agent : agentConnection , initialMessages : [ { role : \"system\" , content : \"You're chatting with our AI assistant.\" }, { role : \"assistant\" , content : \"Hello! How can I help you today?\" }, ] , } ) ; return ( &#x3C; div className = \"chat-container\" > &#x3C; div className = \"message-history\" > { messages . map (( message , i ) => ( &#x3C; div key = { i } className = { `message ${ message . role } ` }> { message . role === \"user\" ? \"👤\" : \"🤖\" } { message . content } &#x3C;/ div > ))} { isLoading &#x26;&#x26; &#x3C; div className = \"loading\" >AI is typing...&#x3C;/ div >} { error &#x26;&#x26; &#x3C; div className = \"error\" >Error: { error . message }&#x3C;/ div >} &#x3C;/ div > &#x3C; form onSubmit = { handleSubmit } className = \"message-input\" > &#x3C; input value = { input } onChange = { handleInputChange } placeholder = \"Type your message...\" disabled = { isLoading } /> &#x3C; button type = \"submit\" disabled = { isLoading || ! input . trim ()}> Send &#x3C;/ button > &#x3C; button type = \"button\" onClick = { clearHistory }> Clear Chat &#x3C;/ button > &#x3C;/ form > &#x3C;/ div > ) ; }   {messages.map((message, i) => (  {message.role === &#x22;user&#x22; ? &#x22;👤&#x22; : &#x22;🤖&#x22;} {message.content}  ))} {isLoading &#x26;&#x26; AI is typing... } {error &#x26;&#x26; Error: {error.message} }     Send   Clear Chat    );}\"> TypeScript // Example of using useAgentChat in a React component import { useAgentChat } from \"agents/ai-react\" ; import { useAgent } from \"agents/react\" ; import { useState } from \"react\" ; function ChatInterface () { // Connect to the chat agent const agentConnection = useAgent ( { agent : \"customer-support\" , name : \"session-12345\" } ) ; // Use the useAgentChat hook with the agent connection const { messages , input , handleInputChange , handleSubmit , isLoading , error , clearHistory } = useAgentChat ( { agent : agentConnection , initialMessages : [ { role : \"system\" , content : \"You're chatting with our AI assistant.\" }, { role : \"assistant\" , content : \"Hello! How can I help you today?\" } ] } ) ; return ( &#x3C; div className = \"chat-container\" > &#x3C; div className = \"message-history\" > { messages . map (( message , i ) => ( &#x3C; div key = { i } className = { `message ${ message . role } ` } > { message . role === ' user ' ? '👤' : '🤖' } { message . content } &#x3C;/ div > )) } { isLoading &#x26;&#x26; &#x3C; div className = \"loading\" > AI is typing ...&#x3C;/ div > } { error &#x26;&#x26; &#x3C; div className = \"error\" > Error : { error. message } &#x3C;/ div > } &#x3C;/ div > &#x3C; form onSubmit = { handleSubmit } className = \"message-input\" > &#x3C; input value = { input } onChange = { handleInputChange } placeholder = \"Type your message...\" disabled = { isLoading } /> &#x3C; button type = \"submit\" disabled = { isLoading || !input.trim() } > Send &#x3C;/ button > &#x3C; button type = \"button\" onClick = { clearHistory } > Clear Chat &#x3C;/ button > &#x3C;/ form > &#x3C;/ div > ) ; }   {messages.map((message, i) => (  {message.role === &#x27;user&#x27; ? &#x27;👤&#x27; : &#x27;🤖&#x27;} {message.content}  ))} {isLoading &#x26;&#x26; AI is typing... } {error &#x26;&#x26; Error: {error.message} }     Send   Clear Chat    );}\"> Next steps Build a chat Agent using the Agents SDK and deploy it to Workers. Learn more using WebSockets to build interactive Agents and stream data back from your Agent. Orchestrate asynchronous workflows from your Agent by combining the Agents SDK and Workflows . Was this helpful? Edit page Last updated: Nov 4, 2025 Previous API Reference Next Calling Agents Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/agents-api/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Using AI Models · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Calling AI Models Long-running model requests Workers AI Hosted models Model routing AI SDK OpenAI compatible endpoints On this page Overview Calling AI Models Long-running model requests Workers AI Hosted models Model routing AI SDK OpenAI compatible endpoints Tags AI Was this helpful? Edit Issue Directory … Agents API Reference Using AI Models Copy page Using AI Models Agents can communicate with AI models hosted on any provider, including: Workers AI The AI SDK ↗ OpenAI ↗ Anthropic ↗ Google's Gemini ↗ You can also use the model routing features in AI Gateway to route across providers, eval responses, and manage AI provider rate limits. Because Agents are built on top of Durable Objects , each Agent or chat session is associated with a stateful compute instance. Traditional serverless architectures often present challenges for persistent connections needed in real-time applications like chat. A user can disconnect during a long-running response from a modern reasoning model (such as o3-mini or DeepSeek R1), or lose conversational context when refreshing the browser. Instead of relying on request-response patterns and managing an external database to track &#x26; store conversation state, state can be stored directly within the Agent. If a client disconnects, the Agent can write to its own distributed storage, and catch the client up as soon as it reconnects: even if it's hours or days later. Calling AI Models You can call models from any method within an Agent, including from HTTP requests using the onRequest handler, when a scheduled task runs, when handling a WebSocket message in the onMessage handler, or from any of your own methods. Importantly, Agents can call AI models on their own — autonomously — and can handle long-running responses that can take minutes (or longer) to respond in full. Long-running model requests Modern reasoning models ↗ or \"thinking\" model can take some time to both generate a response and stream the response back to the client. Instead of buffering the entire response, or risking the client disconnecting, you can stream the response back to the client by using the WebSocket API . JavaScript TypeScript src/index.js import { Agent } from \"agents\" ; import { OpenAI } from \"openai\" ; export class MyAgent extends Agent { async onConnect ( connection , ctx ) { // } async onMessage ( connection , message ) { let msg = JSON . parse ( message ) ; // This can run as long as it needs to, and return as many messages as it needs to! await queryReasoningModel ( connection , msg . prompt ) ; } async queryReasoningModel ( connection , userPrompt ) { const client = new OpenAI ( { apiKey : this . env . OPENAI_API_KEY , } ) ; try { const stream = await client . chat . completions . create ( { model : this . env . MODEL || \"o3-mini\" , messages : [ { role : \"user\" , content : userPrompt } ] , stream : true , } ) ; // Stream responses back as WebSocket messages for await ( const chunk of stream ) { const content = chunk . choices [ 0 ] ?. delta ?. content || \"\" ; if ( content ) { connection . send ( JSON . stringify ( { type : \"chunk\" , content } )) ; } } // Send completion message connection . send ( JSON . stringify ( { type : \"done\" } )) ; } catch ( error ) { connection . send ( JSON . stringify ( { type : \"error\" , error : error } )) ; } } } src/index.ts import { Agent } from \"agents\" ; import { OpenAI } from \"openai\" ; export class MyAgent extends Agent &#x3C; Env > { async onConnect ( connection : Connection , ctx : ConnectionContext ) { // } async onMessage ( connection : Connection , message : WSMessage ) { let msg = JSON . parse ( message ) ; // This can run as long as it needs to, and return as many messages as it needs to! await queryReasoningModel ( connection , msg . prompt ) ; } async queryReasoningModel ( connection : Connection , userPrompt : string ) { const client = new OpenAI ( { apiKey : this . env . OPENAI_API_KEY , } ) ; try { const stream = await client . chat . completions . create ( { model : this . env . MODEL || \"o3-mini\" , messages : [ { role : \"user\" , content : userPrompt } ] , stream : true , } ) ; // Stream responses back as WebSocket messages for await ( const chunk of stream ) { const content = chunk . choices [ 0 ] ?. delta ?. content || \"\" ; if ( content ) { connection . send ( JSON . stringify ( { type : \"chunk\" , content } )) ; } } // Send completion message connection . send ( JSON . stringify ( { type : \"done\" } )) ; } catch ( error ) { connection . send ( JSON . stringify ( { type : \"error\" , error : error } )) ; } } } { async onConnect(connection: Connection, ctx: ConnectionContext) { // } async onMessage(connection: Connection, message: WSMessage) { let msg = JSON.parse(message); // This can run as long as it needs to, and return as many messages as it needs to! await queryReasoningModel(connection, msg.prompt); } async queryReasoningModel(connection: Connection, userPrompt: string) { const client = new OpenAI({ apiKey: this.env.OPENAI_API_KEY, }); try { const stream = await client.chat.completions.create({ model: this.env.MODEL || &#x22;o3-mini&#x22;, messages: [{ role: &#x22;user&#x22;, content: userPrompt }], stream: true, }); // Stream responses back as WebSocket messages for await (const chunk of stream) { const content = chunk.choices[0]?.delta?.content || &#x22;&#x22;; if (content) { connection.send(JSON.stringify({ type: &#x22;chunk&#x22;, content })); } } // Send completion message connection.send(JSON.stringify({ type: &#x22;done&#x22; })); } catch (error) { connection.send(JSON.stringify({ type: &#x22;error&#x22;, error: error })); } }}\"> You can also persist AI model responses back to Agent's internal state by using the this.setState method. For example, if you run a scheduled task , you can store the output of the task and read it later. Or, if a user disconnects, read the message history back and send it to the user when they reconnect. Workers AI Hosted models You can use any of the models available in Workers AI within your Agent by configuring a binding . Workers AI supports streaming responses out-of-the-box by setting stream: true , and we strongly recommend using them to avoid buffering and delaying responses, especially for larger models or reasoning models that require more time to generate a response. JavaScript TypeScript src/index.js import { Agent } from \"agents\" ; export class MyAgent extends Agent { async onRequest ( request ) { const response = await env . AI . run ( \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\" , { prompt : \"Build me a Cloudflare Worker that returns JSON.\" , stream : true , // Stream a response and don't block the client! }, ) ; // Return the stream return new Response ( answer , { headers : { \"content-type\" : \"text/event-stream\" }, } ) ; } } src/index.ts import { Agent } from \"agents\" ; interface Env { AI : Ai ; } export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) { const response = await env . AI . run ( \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\" , { prompt : \"Build me a Cloudflare Worker that returns JSON.\" , stream : true , // Stream a response and don't block the client! }, ) ; // Return the stream return new Response ( answer , { headers : { \"content-type\" : \"text/event-stream\" }, } ) ; } } { async onRequest(request: Request) { const response = await env.AI.run( &#x22;@cf/deepseek-ai/deepseek-r1-distill-qwen-32b&#x22;, { prompt: &#x22;Build me a Cloudflare Worker that returns JSON.&#x22;, stream: true, // Stream a response and don&#x27;t block the client! }, ); // Return the stream return new Response(answer, { headers: { &#x22;content-type&#x22;: &#x22;text/event-stream&#x22; }, }); }}\"> Your Wrangler configuration will need an ai binding added: wrangler.jsonc wrangler.toml { \" $schema \" : \"./node_modules/wrangler/config-schema.json\" , \" ai \" : { \" binding \" : \"AI\" } } [ ai ] binding = \"AI\" Model routing You can also use the model routing features in AI Gateway directly from an Agent by specifying a gateway configuration when calling the AI binding. Note Model routing allows you to route requests to different AI models based on whether they are reachable, rate-limiting your client, and/or if you've exceeded your cost budget for a specific provider. JavaScript TypeScript src/index.js import { Agent } from \"agents\" ; export class MyAgent extends Agent { async onRequest ( request ) { const response = await env . AI . run ( \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\" , { prompt : \"Build me a Cloudflare Worker that returns JSON.\" , }, { gateway : { id : \"{gateway_id}\" , // Specify your AI Gateway ID here skipCache : false , cacheTtl : 3360 , }, }, ) ; return Response . json ( response ) ; } } src/index.ts import { Agent } from \"agents\" ; interface Env { AI : Ai ; } export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) { const response = await env . AI . run ( \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\" , { prompt : \"Build me a Cloudflare Worker that returns JSON.\" , }, { gateway : { id : \"{gateway_id}\" , // Specify your AI Gateway ID here skipCache : false , cacheTtl : 3360 , }, }, ) ; return Response . json ( response ) ; } } { async onRequest(request: Request) { const response = await env.AI.run( &#x22;@cf/deepseek-ai/deepseek-r1-distill-qwen-32b&#x22;, { prompt: &#x22;Build me a Cloudflare Worker that returns JSON.&#x22;, }, { gateway: { id: &#x22;{gateway_id}&#x22;, // Specify your AI Gateway ID here skipCache: false, cacheTtl: 3360, }, }, ); return Response.json(response); }}\"> Your Wrangler configuration will need an ai binding added. This is shared across both Workers AI and AI Gateway. wrangler.jsonc wrangler.toml { \" $schema \" : \"./node_modules/wrangler/config-schema.json\" , \" ai \" : { \" binding \" : \"AI\" } } [ ai ] binding = \"AI\" Visit the AI Gateway documentation to learn how to configure a gateway and retrieve a gateway ID. AI SDK The AI SDK ↗ provides a unified API for using AI models, including for text generation, tool calling, structured responses, image generation, and more. To use the AI SDK, install the ai package and use it within your Agent. The example below shows how it use it to generate text on request, but you can use it from any method within your Agent, including WebSocket handlers, as part of a scheduled task, or even when the Agent is initialized. npm yarn pnpm Terminal window npm i ai @ai-sdk/openai Terminal window yarn add ai @ai-sdk/openai Terminal window pnpm add ai @ai-sdk/openai JavaScript TypeScript src/index.js import { Agent } from \"agents\" ; import { generateText } from \"ai\" ; import { openai } from \"@ai-sdk/openai\" ; export class MyAgent extends Agent { async onRequest ( request ) { const { text } = await generateText ( { model : openai ( \"o3-mini\" ) , prompt : \"Build me an AI agent on Cloudflare Workers\" , } ) ; return Response . json ( { modelResponse : text } ) ; } } src/index.ts import { Agent } from \"agents\" ; import { generateText } from \"ai\" ; import { openai } from \"@ai-sdk/openai\" ; export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) : Promise &#x3C; Response > { const { text } = await generateText ( { model : openai ( \"o3-mini\" ) , prompt : \"Build me an AI agent on Cloudflare Workers\" , } ) ; return Response . json ( { modelResponse : text } ) ; } } { async onRequest(request: Request): Promise { const { text } = await generateText({ model: openai(&#x22;o3-mini&#x22;), prompt: &#x22;Build me an AI agent on Cloudflare Workers&#x22;, }); return Response.json({ modelResponse: text }); }}\"> OpenAI compatible endpoints Agents can call models across any service, including those that support the OpenAI API. For example, you can use the OpenAI SDK to use one of Google's Gemini models ↗ directly from your Agent. Agents can stream responses back over HTTP using Server Sent Events (SSE) from within an onRequest handler, or by using the native WebSockets API in your Agent to responses back to a client, which is especially useful for larger models that can take over 30+ seconds to reply. JavaScript TypeScript src/index.js import { Agent } from \"agents\" ; import { OpenAI } from \"openai\" ; export class MyAgent extends Agent { async onRequest ( request ) { const openai = new OpenAI ( { apiKey : this . env . GEMINI_API_KEY , baseURL : \"https://generativelanguage.googleapis.com/v1beta/openai/\" , } ) ; // Create a TransformStream to handle streaming data let { readable , writable } = new TransformStream () ; let writer = writable . getWriter () ; const textEncoder = new TextEncoder () ; // Use ctx.waitUntil to run the async function in the background // so that it doesn't block the streaming response ctx . waitUntil ( ( async () => { const stream = await openai . chat . completions . create ( { model : \"4o\" , messages : [ { role : \"user\" , content : \"Write me a Cloudflare Worker.\" }, ] , stream : true , } ) ; // loop over the data as it is streamed and write to the writeable for await ( const part of stream ) { writer . write ( textEncoder . encode ( part . choices [ 0 ] ?. delta ?. content || \"\" ) , ) ; } writer . close () ; } )() , ) ; // Return the readable stream back to the client return new Response ( readable ) ; } } { const stream = await openai.chat.completions.create({ model: &#x22;4o&#x22;, messages: [ { role: &#x22;user&#x22;, content: &#x22;Write me a Cloudflare Worker.&#x22; }, ], stream: true, }); // loop over the data as it is streamed and write to the writeable for await (const part of stream) { writer.write( textEncoder.encode(part.choices[0]?.delta?.content || &#x22;&#x22;), ); } writer.close(); })(), ); // Return the readable stream back to the client return new Response(readable); }}\"> src/index.ts import { Agent } from \"agents\" ; import { OpenAI } from \"openai\" ; export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) : Promise &#x3C; Response > { const openai = new OpenAI ( { apiKey : this . env . GEMINI_API_KEY , baseURL : \"https://generativelanguage.googleapis.com/v1beta/openai/\" , } ) ; // Create a TransformStream to handle streaming data let { readable , writable } = new TransformStream () ; let writer = writable . getWriter () ; const textEncoder = new TextEncoder () ; // Use ctx.waitUntil to run the async function in the background // so that it doesn't block the streaming response ctx . waitUntil ( ( async () => { const stream = await openai . chat . completions . create ( { model : \"4o\" , messages : [ { role : \"user\" , content : \"Write me a Cloudflare Worker.\" }, ] , stream : true , } ) ; // loop over the data as it is streamed and write to the writeable for await ( const part of stream ) { writer . write ( textEncoder . encode ( part . choices [ 0 ] ?. delta ?. content || \"\" ) , ) ; } writer . close () ; } )() , ) ; // Return the readable stream back to the client return new Response ( readable ) ; } } { async onRequest(request: Request): Promise { const openai = new OpenAI({ apiKey: this.env.GEMINI_API_KEY, baseURL: &#x22;https://generativelanguage.googleapis.com/v1beta/openai/&#x22;, }); // Create a TransformStream to handle streaming data let { readable, writable } = new TransformStream(); let writer = writable.getWriter(); const textEncoder = new TextEncoder(); // Use ctx.waitUntil to run the async function in the background // so that it doesn&#x27;t block the streaming response ctx.waitUntil( (async () => { const stream = await openai.chat.completions.create({ model: &#x22;4o&#x22;, messages: [ { role: &#x22;user&#x22;, content: &#x22;Write me a Cloudflare Worker.&#x22; }, ], stream: true, }); // loop over the data as it is streamed and write to the writeable for await (const part of stream) { writer.write( textEncoder.encode(part.choices[0]?.delta?.content || &#x22;&#x22;), ); } writer.close(); })(), ); // Return the readable stream back to the client return new Response(readable); }}\"> Was this helpful? Edit page Last updated: Aug 19, 2025 Previous Calling Agents Next Schedule tasks Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/using-ai-models/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Schedule tasks · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Scheduling tasks Managing scheduled tasks On this page Overview Scheduling tasks Managing scheduled tasks Was this helpful? Edit Issue Directory … Agents API Reference Schedule tasks Copy page Schedule tasks An Agent can schedule tasks to be run in the future by calling this.schedule(when, callback, data) , where when can be a delay, a Date , or a cron string; callback the function name to call, and data is an object of data to pass to the function. Scheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent. Scheduling tasks You can call this.schedule within any method on an Agent, and schedule tens-of-thousands of tasks per individual Agent: JavaScript TypeScript JavaScript import { Agent } from \"agents\" ; export class SchedulingAgent extends Agent { async onRequest ( request ) { // Handle an incoming request // Schedule a task 10 minutes from now // Calls the \"checkFlights\" method let { taskId } = await this . schedule ( 600 , \"checkFlights\" , { flight : \"DL264\" , date : \"2025-02-23\" , } ) ; return Response . json ( { taskId } ) ; } async checkFlights ( data ) { // Invoked when our scheduled task runs // We can also call this.schedule here to schedule another task } } TypeScript import { Agent } from \"agents\" export class SchedulingAgent extends Agent { async onRequest ( request ) { // Handle an incoming request // Schedule a task 10 minutes from now // Calls the \"checkFlights\" method let { taskId } = await this . schedule ( 600 , \"checkFlights\" , { flight : \"DL264\" , date : \"2025-02-23\" } ) ; return Response . json ( { taskId } ) ; } async checkFlights ( data ) { // Invoked when our scheduled task runs // We can also call this.schedule here to schedule another task } } Warning Tasks that set a callback for a method that does not exist will throw an exception: ensure that the method named in the callback argument of this.schedule exists on your Agent class. You can schedule tasks in multiple ways: JavaScript TypeScript JavaScript // schedule a task to run in 10 seconds let task = await this . schedule ( 10 , \"someTask\" , { message : \"hello\" } ) ; // schedule a task to run at a specific date let task = await this . schedule ( new Date ( \"2025-01-01\" ) , \"someTask\" , {} ) ; // schedule a task to run every 10 minutes let { id } = await this . schedule ( \"*/10 * * * *\" , \"someTask\" , { message : \"hello\" , } ) ; // schedule a task to run every 10 minutes, but only on Mondays let task = await this . schedule ( \"*/10 * * * 1\" , \"someTask\" , { message : \"hello\" , } ) ; // cancel a scheduled task this . cancelSchedule ( task . id ) ; TypeScript // schedule a task to run in 10 seconds let task = await this . schedule ( 10 , \"someTask\" , { message : \"hello\" } ) ; // schedule a task to run at a specific date let task = await this . schedule ( new Date ( \"2025-01-01\" ) , \"someTask\" , {} ) ; // schedule a task to run every 10 minutes let { id } = await this . schedule ( \"*/10 * * * *\" , \"someTask\" , { message : \"hello\" } ) ; // schedule a task to run every 10 minutes, but only on Mondays let task = await this . schedule ( \"*/10 * * * 1\" , \"someTask\" , { message : \"hello\" } ) ; // cancel a scheduled task this . cancelSchedule ( task . id ) ; Calling await this.schedule returns a Schedule , which includes the task's randomly generated id . You can use this id to retrieve or cancel the task in the future. It also provides a type property that indicates the type of schedule, for example, one of \"scheduled\" | \"delayed\" | \"cron\" . Maximum scheduled tasks Each task is mapped to a row in the Agent's underlying SQLite database , which means that each task can be up to 2 MB in size. The maximum number of tasks must be (task_size * tasks) + all_other_state &#x3C; maximum_database_size (currently 1GB per Agent). Managing scheduled tasks You can get, cancel and filter across scheduled tasks within an Agent using the scheduling API: JavaScript TypeScript JavaScript // Get a specific schedule by ID // Returns undefined if the task does not exist let task = await this . getSchedule ( task . id ) ; // Get all scheduled tasks // Returns an array of Schedule objects let tasks = this . getSchedules () ; // Cancel a task by its ID // Returns true if the task was cancelled, false if it did not exist await this . cancelSchedule ( task . id ) ; // Filter for specific tasks // e.g. all tasks starting in the next hour let tasks = this . getSchedules ( { timeRange : { start : new Date ( Date . now ()) , end : new Date ( Date . now () + 60 * 60 * 1000 ) , }, } ) ; TypeScript // Get a specific schedule by ID // Returns undefined if the task does not exist let task = await this . getSchedule ( task . id ) // Get all scheduled tasks // Returns an array of Schedule objects let tasks = this . getSchedules () ; // Cancel a task by its ID // Returns true if the task was cancelled, false if it did not exist await this . cancelSchedule ( task . id ) ; // Filter for specific tasks // e.g. all tasks starting in the next hour let tasks = this . getSchedules ( { timeRange : { start : new Date ( Date . now ()) , end : new Date ( Date . now () + 60 * 60 * 1000 ) , } } ) ; Was this helpful? Edit page Last updated: Sep 24, 2025 Previous Using AI Models Next Run Workflows Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/schedule-tasks/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Run Workflows · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Trigger a Workflow Trigger a Workflow from another project On this page Overview Trigger a Workflow Trigger a Workflow from another project Was this helpful? Edit Issue Directory … Agents API Reference Run Workflows Copy page Run Workflows Agents can trigger asynchronous Workflows , allowing your Agent to run complex, multi-step tasks in the background. This can include post-processing files that a user has uploaded, updating the embeddings in a vector database , and/or managing long-running user-lifecycle email or SMS notification workflows. Because an Agent is just like a Worker script, it can create Workflows defined in the same project (script) as the Agent or in a different project. Agents vs. Workflows Agents and Workflows have some similarities: they can both run tasks asynchronously. For straightforward tasks that are linear or need to run to completion, a Workflow can be ideal: steps can be retried, they can be cancelled, and can act on events. Agents do not have to run to completion: they can loop, branch and run forever, and they can also interact directly with users (over HTTP or WebSockets). An Agent can be used to trigger multiple Workflows as it runs, and can thus be used to co-ordinate and manage Workflows to achieve its goals. Trigger a Workflow An Agent can trigger one or more Workflows from within any method, whether from an incoming HTTP request, a WebSocket connection, on a delay or schedule, and/or from any other action the Agent takes. Triggering a Workflow from an Agent is no different from triggering a Workflow from a Worker script : JavaScript TypeScript JavaScript export class MyAgent extends Agent { async onRequest ( request ) { let userId = request . headers . get ( \"user-id\" ) ; // Trigger a schedule that runs a Workflow // Pass it a payload let { taskId } = await this . schedule ( 300 , \"runWorkflow\" , { id : userId , flight : \"DL264\" , date : \"2025-02-23\" , } ) ; } async runWorkflow ( data ) { let instance = await env . MY_WORKFLOW . create ( { id : data . id , params : data , } ) ; // Schedule another task that checks the Workflow status every 5 minutes... await this . schedule ( \"*/5 * * * *\" , \"checkWorkflowStatus\" , { id : instance . id , } ) ; } } export class MyWorkflow extends WorkflowEntrypoint { async run ( event , step ) { // Your Workflow code here } } TypeScript interface Env { MY_WORKFLOW : Workflow ; MyAgent : AgentNamespace &#x3C; MyAgent >; } export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) { let userId = request . headers . get ( \"user-id\" ) ; // Trigger a schedule that runs a Workflow // Pass it a payload let { taskId } = await this . schedule ( 300 , \"runWorkflow\" , { id : userId , flight : \"DL264\" , date : \"2025-02-23\" } ) ; } async runWorkflow ( data ) { let instance = await env . MY_WORKFLOW . create ( { id : data . id , params : data , } ) // Schedule another task that checks the Workflow status every 5 minutes... await this . schedule ( \"*/5 * * * *\" , \"checkWorkflowStatus\" , { id : instance . id } ) ; } } export class MyWorkflow extends WorkflowEntrypoint &#x3C; Env > { async run ( event : WorkflowEvent &#x3C; Params >, step : WorkflowStep ) { // Your Workflow code here } } ;}export class MyAgent extends Agent { async onRequest(request: Request) { let userId = request.headers.get(&#x22;user-id&#x22;); // Trigger a schedule that runs a Workflow // Pass it a payload let { taskId } = await this.schedule(300, &#x22;runWorkflow&#x22;, { id: userId, flight: &#x22;DL264&#x22;, date: &#x22;2025-02-23&#x22; }); } async runWorkflow(data) { let instance = await env.MY_WORKFLOW.create({ id: data.id, params: data, }) // Schedule another task that checks the Workflow status every 5 minutes... await this.schedule(&#x22;*/5 * * * *&#x22;, &#x22;checkWorkflowStatus&#x22;, { id: instance.id }); }}export class MyWorkflow extends WorkflowEntrypoint { async run(event: WorkflowEvent , step: WorkflowStep) { // Your Workflow code here }}\"> You'll also need to make sure your Agent has a binding to your Workflow so that it can call it: wrangler.jsonc wrangler.toml { // ... // Create a binding between your Agent and your Workflow \" workflows \" : [ { // Required: \" name \" : \"EMAIL_WORKFLOW\" , \" class_name \" : \"MyWorkflow\" , // Optional: set the script_name field if your Workflow is defined in a // different project from your Agent \" script_name \" : \"email-workflows\" } ], // ... } [[ workflows ]] name = \"EMAIL_WORKFLOW\" class_name = \"MyWorkflow\" script_name = \"email-workflows\" Trigger a Workflow from another project You can also call a Workflow that is defined in a different Workers script from your Agent by setting the script_name property in the workflows binding of your Agent: wrangler.jsonc wrangler.toml { // Required: \" name \" : \"EMAIL_WORKFLOW\" , \" class_name \" : \"MyWorkflow\" , // Optional: set the script_name field if your Workflow is defined in a // different project from your Agent \" script_name \" : \"email-workflows\" } name = \"EMAIL_WORKFLOW\" class_name = \"MyWorkflow\" script_name = \"email-workflows\" Refer to the cross-script calls section of the Workflows documentation for more examples. Was this helpful? Edit page Last updated: May 14, 2025 Previous Schedule tasks Next Store and sync state Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/run-workflows/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Store and sync state · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Set the initial state for an Agent Synchronizing state SQL API Use Agent state as model context Next steps On this page Overview Set the initial state for an Agent Synchronizing state SQL API Use Agent state as model context Next steps Was this helpful? Edit Issue Directory … Agents API Reference Store and sync state Copy page Store and sync state Every Agent has built-in state management capabilities, including built-in storage and synchronization between the Agent and frontend applications. State within an Agent is: Persisted across Agent restarts: data is permanently stored within an Agent. Automatically serialized/deserialized: you can store any JSON-serializable data. Immediately consistent within the Agent: read your own writes. Thread-safe for concurrent updates Fast: state is colocated wherever the Agent is running. Reads and writes do not need to traverse the network. Agent state is stored in a SQL database that is embedded within each individual Agent instance: you can interact with it using the higher-level this.setState API (recommended), which allows you to sync state and trigger events on state changes, or by directly querying the database with this.sql . State API Every Agent has built-in state management capabilities. You can set and update the Agent's state directly using this.setState : JavaScript TypeScript JavaScript import { Agent } from \"agents\" ; export class MyAgent extends Agent { // Update state in response to events async incrementCounter () { this . setState ( { ... this . state , counter : this . state . counter + 1 , } ) ; } // Handle incoming messages async onMessage ( message ) { if ( message . type === \"update\" ) { this . setState ( { ... this . state , ... message . data , } ) ; } } // Handle state updates onStateUpdate ( state , source ) { console . log ( \"state updated\" , state ) ; } } TypeScript import { Agent } from \"agents\" ; export class MyAgent extends Agent { // Update state in response to events async incrementCounter () { this . setState ( { ... this . state , counter : this . state . counter + 1 , } ) ; } // Handle incoming messages async onMessage ( message ) { if ( message . type === \"update\" ) { this . setState ( { ... this . state , ... message . data , } ) ; } } // Handle state updates onStateUpdate ( state , source : \"server\" | Connection ) { console . log ( \"state updated\" , state ) ; } } If you're using TypeScript, you can also provide a type for your Agent's state by passing in a type as a type parameter ↗ as the second type parameter to the Agent class definition. JavaScript TypeScript JavaScript import { Agent } from \"agents\" ; // Define a type for your Agent's state // Pass in the type of your Agent's state export class MyAgent extends Agent { // This allows this.setState and the onStateUpdate method to // be typed: async onStateUpdate ( state ) { console . log ( \"state updated\" , state ) ; } async someOtherMethod () { this . setState ( { ... this . state , price : this . state . price + 10 , } ) ; } } TypeScript import { Agent } from \"agents\" ; interface Env {} // Define a type for your Agent's state interface FlightRecord { id : string ; departureIata : string ; arrival : Date ; arrivalIata : string ; price : number ; } // Pass in the type of your Agent's state export class MyAgent extends Agent &#x3C; Env , FlightRecord > { // This allows this.setState and the onStateUpdate method to // be typed: async onStateUpdate ( state : FlightRecord ) { console . log ( \"state updated\" , state ) ; } async someOtherMethod () { this . setState ( { ... this . state , price : this . state . price + 10 , } ) ; } } { // This allows this.setState and the onStateUpdate method to // be typed: async onStateUpdate(state: FlightRecord) { console.log(&#x22;state updated&#x22;, state); } async someOtherMethod() { this.setState({ ...this.state, price: this.state.price + 10, }); }}\"> Set the initial state for an Agent You can also set the initial state for an Agent via the initialState property on the Agent class: JavaScript TypeScript JavaScript class MyAgent extends Agent { // Set a default, initial state initialState = { counter : 0 , text : \"\" , color : \"#3B82F6\" , }; doSomething () { console . log ( this . state ) ; // {counter: 0, text: \"\", color: \"#3B82F6\"}, if you haven't set the state yet } } TypeScript type State = { counter : number ; text : string ; color : string ; }; class MyAgent extends Agent &#x3C; Env , State > { // Set a default, initial state initialState = { counter : 0 , text : \"\" , color : \"#3B82F6\" , }; doSomething () { console . log ( this . state ) ; // {counter: 0, text: \"\", color: \"#3B82F6\"}, if you haven't set the state yet } } { // Set a default, initial state initialState = { counter: 0, text: &#x22;&#x22;, color: &#x22;#3B82F6&#x22;, }; doSomething() { console.log(this.state); // {counter: 0, text: &#x22;&#x22;, color: &#x22;#3B82F6&#x22;}, if you haven&#x27;t set the state yet }}\"> Any initial state is synced to clients connecting via the useAgent hook . Synchronizing state Clients can connect to an Agent and stay synchronized with its state using the React hooks provided as part of agents/react . A React application can call useAgent to connect to a named Agent over WebSockets at JavaScript TypeScript JavaScript import { useState } from \"react\" ; import { useAgent } from \"agents/react\" ; function StateInterface () { const [ state , setState ] = useState ( { counter : 0 } ) ; const agent = useAgent ( { agent : \"thinking-agent\" , name : \"my-agent\" , onStateUpdate : ( newState ) => setState ( newState ) , } ) ; const increment = () => { agent . setState ( { counter : state . counter + 1 } ) ; }; return ( &#x3C; div > &#x3C; div >Count: { state . counter }&#x3C;/ div > &#x3C; button onClick = { increment }>Increment&#x3C;/ button > &#x3C;/ div > ) ; } setState(newState), }); const increment = () => { agent.setState({ counter: state.counter + 1 }); }; return (  Count: {state.counter}  Increment   );}\"> TypeScript import { useState } from \"react\" ; import { useAgent } from \"agents/react\" ; function StateInterface () { const [ state , setState ] = useState ( { counter : 0 } ) ; const agent = useAgent ( { agent : \"thinking-agent\" , name : \"my-agent\" , onStateUpdate : ( newState ) => setState ( newState ) , } ) ; const increment = () => { agent . setState ( { counter : state . counter + 1 } ) ; }; return ( &#x3C; div > &#x3C; div > Count : { state . counter }&#x3C; / div > &#x3C; button onClick = { increment } > Increment &#x3C;/ button > &#x3C;/ div > ) ; } setState(newState), }); const increment = () => { agent.setState({ counter: state.counter + 1 }); }; return (  Count: {state.counter}  Increment   );}\"> The state synchronization system: Automatically syncs the Agent's state to all connected clients Handles client disconnections and reconnections gracefully Provides immediate local updates Supports multiple simultaneous client connections Common use cases: Real-time collaborative features Multi-window/tab synchronization Live updates across multiple devices Maintaining consistent UI state across clients When new clients connect, they automatically receive the current state from the Agent, ensuring all clients start with the latest data. SQL API Every individual Agent instance has its own SQL (SQLite) database that runs within the same context as the Agent itself. This means that inserting or querying data within your Agent is effectively zero-latency: the Agent doesn't have to round-trip across a continent or the world to access its own data. You can access the SQL API within any method on an Agent via this.sql . The SQL API accepts template literals, and JavaScript TypeScript JavaScript export class MyAgent extends Agent { async onRequest ( request ) { let userId = new URL ( request . url ) . searchParams . get ( \"userId\" ) ; // 'users' is just an example here: you can create arbitrary tables and define your own schemas // within each Agent's database using SQL (SQLite syntax). let [ user ] = this . sql `SELECT * FROM users WHERE id = ${ userId } ` ; return Response . json ( user ) ; } } TypeScript export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) { let userId = new URL ( request . url ) . searchParams . get ( 'userId' ) ; // 'users' is just an example here: you can create arbitrary tables and define your own schemas // within each Agent's database using SQL (SQLite syntax). let [ user ] = this . sql `SELECT * FROM users WHERE id = ${ userId } ` return Response . json ( user ) } } { async onRequest(request: Request) { let userId = new URL(request.url).searchParams.get(&#x27;userId&#x27;); // &#x27;users&#x27; is just an example here: you can create arbitrary tables and define your own schemas // within each Agent&#x27;s database using SQL (SQLite syntax). let [user] = this.sql&#x60;SELECT * FROM users WHERE id = ${userId}&#x60; return Response.json(user) }}\"> You can also supply a TypeScript type argument ↗ to the query, which will be used to infer the type of the result: TypeScript type User = { id : string ; name : string ; email : string ; }; export class MyAgent extends Agent &#x3C; Env > { async onRequest ( request : Request ) { let userId = new URL ( request . url ) . searchParams . get ( 'userId' ) ; // Supply the type parameter to the query when calling this.sql // This assumes the results returns one or more User rows with \"id\", \"name\", and \"email\" columns const [ user ] = this . sql &#x3C; User > `SELECT * FROM users WHERE id = ${ userId } ` ; return Response . json ( user ) } } { async onRequest(request: Request) { let userId = new URL(request.url).searchParams.get(&#x27;userId&#x27;); // Supply the type parameter to the query when calling this.sql // This assumes the results returns one or more User rows with &#x22;id&#x22;, &#x22;name&#x22;, and &#x22;email&#x22; columns const [user] = this.sql &#x60;SELECT * FROM users WHERE id = ${userId}&#x60;; return Response.json(user) }}\"> You do not need to specify an array type ( User[] or Array&#x3C;User> ) as this.sql will always return an array of the specified type. Providing a type parameter does not validate that the result matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as zod ↗ or your own validator logic. Note Learn more about the zero-latency SQL storage that powers both Agents and Durable Objects on our blog ↗ . The SQL API exposed to an Agent is similar to the one within Durable Objects : Durable Object SQL methods available on this.ctx.storage.sql . You can use the same SQL queries with the Agent's database, create tables, and query data, just as you would with Durable Objects or D1 . Use Agent state as model context You can combine the state and SQL APIs in your Agent with its ability to call AI models to include historical context within your prompts to a model. Modern Large Language Models (LLMs) often have very large context windows (up to millions of tokens), which allows you to pull relevant context into your prompt directly. For example, you can use an Agent's built-in SQL database to pull history, query a model with it, and append to that history ahead of the next call to the model: JavaScript TypeScript JavaScript export class ReasoningAgent extends Agent { async callReasoningModel ( prompt ) { let result = this . sql `SELECT * FROM history WHERE user = ${ prompt . userId } ORDER BY timestamp DESC LIMIT 1000` ; let context = [] ; for ( const row of result ) { context . push ( row . entry ) ; } const client = new OpenAI ( { apiKey : this . env . OPENAI_API_KEY , } ) ; // Combine user history with the current prompt const systemPrompt = prompt . system || \"You are a helpful assistant.\" ; const userPrompt = ` ${ prompt . user } \\n\\n User history: \\n ${ context . join ( \" \\n \" ) } ` ; try { const completion = await client . chat . completions . create ( { model : this . env . MODEL || \"o3-mini\" , messages : [ { role : \"system\" , content : systemPrompt }, { role : \"user\" , content : userPrompt }, ] , temperature : 0.7 , max_tokens : 1000 , } ) ; // Store the response in history this . sql `INSERT INTO history (timestamp, user, entry) VALUES ( ${ new Date () } , ${ prompt . userId } , ${ completion . choices [ 0 ] . message . content } )` ; return completion . choices [ 0 ] . message . content ; } catch ( error ) { console . error ( \"Error calling reasoning model:\" , error ) ; throw error ; } } } TypeScript export class ReasoningAgent extends Agent &#x3C; Env > { async callReasoningModel ( prompt : Prompt ) { let result = this . sql &#x3C; History > `SELECT * FROM history WHERE user = ${ prompt . userId } ORDER BY timestamp DESC LIMIT 1000` ; let context = [] ; for ( const row of result ) { context . push ( row . entry ) ; } const client = new OpenAI ( { apiKey : this . env . OPENAI_API_KEY , } ) ; // Combine user history with the current prompt const systemPrompt = prompt . system || 'You are a helpful assistant.' ; const userPrompt = ` ${ prompt . user } \\n\\n User history: \\n ${ context . join ( ' \\n ' ) } ` ; try { const completion = await client . chat . completions . create ( { model : this . env . MODEL || 'o3-mini' , messages : [ { role : 'system' , content : systemPrompt }, { role : 'user' , content : userPrompt }, ] , temperature : 0.7 , max_tokens : 1000 , } ) ; // Store the response in history this . sql `INSERT INTO history (timestamp, user, entry) VALUES ( ${ new Date () } , ${ prompt . userId } , ${ completion . choices [ 0 ] . message . content } )` ; return completion . choices [ 0 ] . message . content ; } catch ( error ) { console . error ( 'Error calling reasoning model:' , error ) ; throw error ; } } } { async callReasoningModel(prompt: Prompt) { let result = this.sql &#x60;SELECT * FROM history WHERE user = ${prompt.userId} ORDER BY timestamp DESC LIMIT 1000&#x60;; let context = []; for (const row of result) { context.push(row.entry); } const client = new OpenAI({ apiKey: this.env.OPENAI_API_KEY, }); // Combine user history with the current prompt const systemPrompt = prompt.system || &#x27;You are a helpful assistant.&#x27;; const userPrompt = &#x60;${prompt.user}\\n\\nUser history:\\n${context.join(&#x27;\\n&#x27;)}&#x60;; try { const completion = await client.chat.completions.create({ model: this.env.MODEL || &#x27;o3-mini&#x27;, messages: [ { role: &#x27;system&#x27;, content: systemPrompt }, { role: &#x27;user&#x27;, content: userPrompt }, ], temperature: 0.7, max_tokens: 1000, }); // Store the response in history this .sql&#x60;INSERT INTO history (timestamp, user, entry) VALUES (${new Date()}, ${prompt.userId}, ${completion.choices[0].message.content})&#x60;; return completion.choices[0].message.content; } catch (error) { console.error(&#x27;Error calling reasoning model:&#x27;, error); throw error; } }}\"> This works because each instance of an Agent has its own database, the state stored in that database is private to that Agent: whether it's acting on behalf of a single user, a room or channel, or a deep research tool. By default, you don't have to manage contention or reach out over the network to a centralized database to retrieve and store state. Next steps Review the API documentation for the Agents class to learn how to define them. Build a chat Agent using the Agents SDK and deploy it to Workers. Learn more using WebSockets to build interactive Agents and stream data back from your Agent. Orchestrate asynchronous workflows from your Agent by combining the Agents SDK and Workflows . Was this helpful? Edit page Last updated: Oct 23, 2025 Previous Run Workflows Next Browse the web Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Using WebSockets · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Connecting clients React clients Handling WebSocket events On this page Overview Connecting clients React clients Handling WebSocket events Was this helpful? Edit Issue Directory … Agents API Reference Using WebSockets Copy page Using WebSockets Users and clients can connect to an Agent directly over WebSockets, allowing long-running, bi-directional communication with your Agent as it operates. To enable an Agent to accept WebSockets, define onConnect and onMessage methods on your Agent. onConnect(connection: Connection, ctx: ConnectionContext) is called when a client establishes a new WebSocket connection. The original HTTP request, including request headers, cookies, and the URL itself, are available on ctx.request . onMessage(connection: Connection, message: WSMessage) is called for each incoming WebSocket message. Messages are one of ArrayBuffer | ArrayBufferView | string , and you can send messages back to a client using connection.send() . You can distinguish between client connections by checking connection.id , which is unique for each connected client. Here's an example of an Agent that echoes back any message it receives: JavaScript TypeScript JavaScript import { Agent , Connection } from \"agents\" ; export class ChatAgent extends Agent { async onConnect ( connection , ctx ) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } async onMessage ( connection , message ) { // const response = await longRunningAITask(message) await connection . send ( message ) ; } } TypeScript import { Agent , Connection } from \"agents\" ; export class ChatAgent extends Agent { async onConnect ( connection : Connection , ctx : ConnectionContext ) { // Connections are automatically accepted by the SDK. // You can also explicitly close a connection here with connection.close() // Access the Request on ctx.request to inspect headers, cookies and the URL } async onMessage ( connection : Connection , message : WSMessage ) { // const response = await longRunningAITask(message) await connection . send ( message ) } } Connecting clients The Agent framework includes a useful helper package for connecting directly to your Agent (or other Agents) from a client application. Import agents/client , create an instance of AgentClient and use it to connect to an instance of your Agent: JavaScript TypeScript JavaScript import { AgentClient } from \"agents/client\" ; const connection = new AgentClient ( { agent : \"dialogue-agent\" , name : \"insight-seeker\" , } ) ; connection . addEventListener ( \"message\" , ( event ) => { console . log ( \"Received:\" , event . data ) ; } ) ; connection . send ( JSON . stringify ( { type : \"inquiry\" , content : \"What patterns do you see?\" , } ) , ) ; { console.log(&#x22;Received:&#x22;, event.data);});connection.send( JSON.stringify({ type: &#x22;inquiry&#x22;, content: &#x22;What patterns do you see?&#x22;, }),);\"> TypeScript import { AgentClient } from \"agents/client\" ; const connection = new AgentClient ( { agent : \"dialogue-agent\" , name : \"insight-seeker\" , } ) ; connection . addEventListener ( \"message\" , ( event ) => { console . log ( \"Received:\" , event . data ) ; } ) ; connection . send ( JSON . stringify ( { type : \"inquiry\" , content : \"What patterns do you see?\" , } ) ) ; { console.log(&#x22;Received:&#x22;, event.data);});connection.send( JSON.stringify({ type: &#x22;inquiry&#x22;, content: &#x22;What patterns do you see?&#x22;, }));\"> React clients React-based applications can import agents/react and use the useAgent hook to connect to an instance of an Agent directly: JavaScript TypeScript JavaScript import { useAgent } from \"agents/react\" ; function AgentInterface () { const connection = useAgent ( { agent : \"dialogue-agent\" , name : \"insight-seeker\" , onMessage : ( message ) => { console . log ( \"Understanding received:\" , message . data ) ; }, onOpen : () => console . log ( \"Connection established\" ) , onClose : () => console . log ( \"Connection closed\" ) , } ) ; const inquire = () => { connection . send ( JSON . stringify ( { type : \"inquiry\" , content : \"What insights have you gathered?\" , } ) , ) ; }; return ( &#x3C; div className = \"agent-interface\" > &#x3C; button onClick = { inquire }>Seek Understanding&#x3C;/ button > &#x3C;/ div > ) ; } { console.log(&#x22;Understanding received:&#x22;, message.data); }, onOpen: () => console.log(&#x22;Connection established&#x22;), onClose: () => console.log(&#x22;Connection closed&#x22;), }); const inquire = () => { connection.send( JSON.stringify({ type: &#x22;inquiry&#x22;, content: &#x22;What insights have you gathered?&#x22;, }), ); }; return (  Seek Understanding   );}\"> TypeScript import { useAgent } from \"agents/react\" ; function AgentInterface () { const connection = useAgent ( { agent : \"dialogue-agent\" , name : \"insight-seeker\" , onMessage : ( message ) => { console . log ( \"Understanding received:\" , message . data ) ; }, onOpen : () => console . log ( \"Connection established\" ) , onClose : () => console . log ( \"Connection closed\" ) , } ) ; const inquire = () => { connection . send ( JSON . stringify ( { type : \"inquiry\" , content : \"What insights have you gathered?\" , } ) ) ; }; return ( &#x3C; div className = \"agent-interface\" > &#x3C; button onClick = { inquire } > Seek Understanding &#x3C;/ button > &#x3C;/ div > ) ; } { console.log(&#x22;Understanding received:&#x22;, message.data); }, onOpen: () => console.log(&#x22;Connection established&#x22;), onClose: () => console.log(&#x22;Connection closed&#x22;), }); const inquire = () => { connection.send( JSON.stringify({ type: &#x22;inquiry&#x22;, content: &#x22;What insights have you gathered?&#x22;, }) ); }; return (  Seek Understanding   );}\"> The useAgent hook automatically handles the lifecycle of the connection, ensuring that it is properly initialized and cleaned up when the component mounts and unmounts. You can also combine useAgent with useState to automatically synchronize state across all clients connected to your Agent. Handling WebSocket events Define onError and onClose methods on your Agent to explicitly handle WebSocket client errors and close events. Log errors, clean up state, and/or emit metrics: JavaScript TypeScript JavaScript import { Agent , Connection } from \"agents\" ; export class ChatAgent extends Agent { // onConnect and onMessage methods // ... // WebSocket error and disconnection (close) handling. async onError ( connection , error ) { console . error ( `WS error: ${ error } ` ) ; } async onClose ( connection , code , reason , wasClean ) { console . log ( `WS closed: ${ code } - ${ reason } - wasClean: ${ wasClean } ` ) ; connection . close () ; } } TypeScript import { Agent , Connection } from \"agents\" ; export class ChatAgent extends Agent { // onConnect and onMessage methods // ... // WebSocket error and disconnection (close) handling. async onError ( connection : Connection , error : unknown ) : Promise &#x3C; void > { console . error ( `WS error: ${ error } ` ) ; } async onClose ( connection : Connection , code : number , reason : string , wasClean : boolean ) : Promise &#x3C; void > { console . log ( `WS closed: ${ code } - ${ reason } - wasClean: ${ wasClean } ` ) ; connection . close () ; } } { console.error(&#x60;WS error: ${error}&#x60;); } async onClose(connection: Connection, code: number, reason: string, wasClean: boolean): Promise { console.log(&#x60;WS closed: ${code} - ${reason} - wasClean: ${wasClean}&#x60;); connection.close(); }}\"> Was this helpful? Edit page Last updated: Mar 18, 2025 Previous Retrieval Augmented Generation Next Configuration Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/websockets/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Configuration · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Project structure Example configuration On this page Overview Project structure Example configuration Was this helpful? Edit Issue Directory … Agents API Reference Configuration Copy page Configuration An Agent is configured like any other Cloudflare Workers project, and uses a wrangler configuration file to define where your code is and what services (bindings) it will use. Project structure The typical file structure for an Agent project created from npm create cloudflare@latest agents-starter -- --template cloudflare/agents-starter follows: Terminal window . | -- package-lock.json | -- package.json | -- public | ` -- index.html | -- src | ` -- index.ts // your Agent definition | -- test | | -- index.spec.ts // your tests | ` -- tsconfig.json | -- tsconfig.json | -- vitest.config.mts | -- worker-configuration.d.ts ` -- wrangler.jsonc // your Workers &#x26; Agent configuration Example configuration Below is a minimal wrangler.jsonc file that defines the configuration for an Agent, including the entry point, durable_object namespace, and code migrations : wrangler.jsonc wrangler.toml { \" $schema \" : \"node_modules/wrangler/config-schema.json\" , \" name \" : \"agents-example\" , \" main \" : \"src/index.ts\" , \" compatibility_date \" : \"2025-02-23\" , \" compatibility_flags \" : [ \"nodejs_compat\" ], \" durable_objects \" : { \" bindings \" : [ { // Required: \" name \" : \"MyAgent\" , // How your Agent is called from your Worker \" class_name \" : \"MyAgent\" , // Must match the class name of the Agent in your code // Optional: set this if the Agent is defined in another Worker script \" script_name \" : \"the-other-worker\" }, ], }, \" migrations \" : [ { \" tag \" : \"v1\" , // Mandatory for the Agent to store state \" new_sqlite_classes \" : [ \"MyAgent\" ], }, ], \" observability \" : { \" enabled \" : true , }, } \" $schema \" = \"node_modules/wrangler/config-schema.json\" name = \"agents-example\" main = \"src/index.ts\" compatibility_date = \"2025-02-23\" compatibility_flags = [ \"nodejs_compat\" ] [[ durable_objects . bindings ]] name = \"MyAgent\" class_name = \"MyAgent\" script_name = \"the-other-worker\" [[ migrations ]] tag = \"v1\" new_sqlite_classes = [ \"MyAgent\" ] [ observability ] enabled = true The configuration includes: A main field that points to the entry point of your Agent, which is typically a TypeScript (or JavaScript) file. A durable_objects field that defines the Durable Object namespace that your Agents will run within. A migrations field that defines the code migrations that your Agent will use. This field is mandatory and must contain at least one migration. The new_sqlite_classes field is mandatory for the Agent to store state. Agents must define these fields in their wrangler.jsonc (or wrangler.toml ) config file. Was this helpful? Edit page Last updated: Mar 18, 2025 Previous Using WebSockets Next Patterns Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/api-reference/configuration/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Tools · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview On this page Overview Was this helpful? Edit Issue Directory … Agents Model Context Protocol (MCP) Tools Copy page Tools Model Context Protocol (MCP) tools are functions that a MCP Server provides and MCP clients can call. When you build MCP Servers with the agents package, you can define tools the same way as shown in the @modelcontextprotocol/typescript-sdk package's examples ↗ . For example, the following code from this example MCP server ↗ defines a simple MCP server that adds two numbers together: JavaScript TypeScript JavaScript import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp\" ; import { McpAgent } from \"agents/mcp\" ; export class MyMCP extends McpAgent { server = new McpServer ( { name : \"Demo\" , version : \"1.0.0\" } ) ; async init () { this . server . tool ( \"add\" , { a : z . number () , b : z . number () }, async ({ a , b }) => ( { content : [ { type : \"text\" , text : String ( a + b ) } ] , } ) , ) ; } } ({ content: [{ type: &#x22;text&#x22;, text: String(a + b) }], }), ); }}\"> TypeScript import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp\" ; import { McpAgent } from \"agents/mcp\" ; export class MyMCP extends McpAgent { server = new McpServer ( { name : \"Demo\" , version : \"1.0.0\" } ) ; async init () { this . server . tool ( \"add\" , { a : z . number () , b : z . number () }, async ({ a , b }) => ( { content : [ { type : \"text\" , text : String ( a + b ) } ] , } ) , ) ; } } ({ content: [{ type: &#x22;text&#x22;, text: String(a + b) }], }), ); }}\"> Was this helpful? Edit page Last updated: Aug 21, 2025 Previous Authorization Next Transport Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/model-context-protocol/tools/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  },
  {
    "id": "index-0",
    "text": "Transport · Cloudflare Agents docs Skip to content Cloudflare Docs Search Docs Directory APIs SDKs Help Log in Select theme Dark Light Auto Agents No results found. Try a different search term, or use our global search . Overview Getting started Build a Chat Agent ↗ Testing your Agents Prompt an AI model ↗ Concepts Agents Workflows Tools Agent class internals Human in the Loop Calling LLMs API Reference Overview Agents API Calling Agents Using AI Models Schedule tasks Run Workflows Store and sync state Browse the web HTTP and Server-Sent Events Retrieval Augmented Generation Using WebSockets Configuration Patterns Guides Build a Human-in-the-loop Agent ↗ Implement Effective Agent Patterns ↗ Build a Remote MCP server Build a Slack Agent Connect to an MCP server Build an Interactive ChatGPT App Test a Remote MCP Server Build a Remote MCP Client ↗ Handle OAuth with MCP servers Model Context Protocol (MCP) Overview Authorization Tools Transport McpAgent — API Reference McpClient — API reference Cloudflare&#39;s own MCP servers MCP server portals ↗ x402 Platform Limits Prompt Engineering ↗ prompt.txt ↗ LLM resources llms.txt prompt.txt Agents llms-full.txt Developer Platform llms-full.txt GitHub X.com YouTube Select theme Dark Light Auto On this page Overview Implementing remote MCP transport Upgrading an existing remote MCP server Testing with MCP clients On this page Overview Implementing remote MCP transport Upgrading an existing remote MCP server Testing with MCP clients Tags MCP Was this helpful? Edit Issue Directory … Agents Model Context Protocol (MCP) Transport Copy page Transport The Model Context Protocol (MCP) specification defines three standard transport mechanisms ↗ for communication between clients and servers: stdio, communication over standard in and standard out — designed for local MCP connections. Server-Sent Events (SSE) — Currently supported by most remote MCP clients, but is expected to be replaced by Streamable HTTP over time. It requires two endpoints: one for sending requests, another for receiving streamed responses. Streamable HTTP — New transport method introduced ↗ in March 2025. It simplifies the communication by using a single HTTP endpoint for bidirectional messaging. It is currently gaining adoption among remote MCP clients, but it is expected to become the standard transport in the future. MCP servers built with the Agents SDK can support both remote transport methods (SSE and Streamable HTTP), with the McpAgent class ↗ automatically handling the transport configuration. Implementing remote MCP transport If you're building a new MCP server or upgrading an existing one on Cloudflare, we recommend supporting both remote transport methods (SSE and Streamable HTTP) concurrently to ensure compatibility with all MCP clients. Get started quickly You can use the \"Deploy to Cloudflare\" button to create a remote MCP server that automatically supports both SSE and Streamable HTTP transport methods. Remote MCP server (without authentication) If you're manually configuring your MCP server, here's how to use the McpAgent class to handle both transport methods: JavaScript TypeScript Hono JavaScript export default { fetch ( request : Request , env : Env , ctx : ExecutionContext ) { const { pathname } = new URL ( request . url ) ; if ( pathname . startsWith ( '/sse' )) { return MyMcpAgent . serveSSE ( '/sse' ) . fetch ( request , env , ctx ) ; } if ( pathname . startsWith ( '/mcp' )) { return MyMcpAgent . serve ( '/mcp' ) . fetch ( request , env , ctx ) ; } }, }; TypeScript export default { fetch ( request : Request , env : Env , ctx : ExecutionContext ) : Response | Promise &#x3C; Response > { const { pathname } = new URL ( request . url ) ; if ( pathname . startsWith ( '/sse' )) { return MyMcpAgent . serveSSE ( '/sse' ) . fetch ( request , env , ctx ) ; } if ( pathname . startsWith ( '/mcp' )) { return MyMcpAgent . serve ( '/mcp' ) . fetch ( request , env , ctx ) ; } // Handle case where no path matches return new Response ( 'Not found' , { status : 404 } ) ; }, }; { const { pathname } = new URL(request.url); if (pathname.startsWith(&#x27;/sse&#x27;)) { return MyMcpAgent.serveSSE(&#x27;/sse&#x27;).fetch(request, env, ctx); } if (pathname.startsWith(&#x27;/mcp&#x27;)) { return MyMcpAgent.serve(&#x27;/mcp&#x27;).fetch(request, env, ctx); } // Handle case where no path matches return new Response(&#x27;Not found&#x27;, { status: 404 }); },};\"> TypeScript const app = new Hono () app . mount ( '/sse' , MyMCP . serveSSE ( '/sse' ) . fetch , { replaceRequest : false } ) app . mount ( '/mcp' , MyMCP . serve ( '/mcp' ) . fetch , { replaceRequest : false ) export default app MCP server with authentication If your MCP server implements authentication &#x26; authorization using the Workers OAuth Provider ↗ Library, then you can configure it to support both transport methods using the apiHandlers property. JavaScript export default new OAuthProvider ( { apiHandlers : { '/sse' : MyMCP . serveSSE ( '/sse' ) , '/mcp' : MyMCP . serve ( '/mcp' ) , }, // ... other OAuth configuration } ) Upgrading an existing remote MCP server If you've already built a remote MCP server using the Cloudflare Agents SDK, make the following changes to support the new Streamable HTTP transport while maintaining compatibility with remote MCP clients using SSE: Use MyMcpAgent.serveSSE('/sse') for the existing SSE transport. Previously, this would have been MyMcpAgent.mount('/sse') , which has been kept as an alias. Add a new path with MyMcpAgent.serve('/mcp') to support the new Streamable HTTP transport. If you have an MCP server with authentication/authorization using the Workers OAuth Provider, update the configuration to use the apiHandlers property, which replaces apiRoute and apiHandler . Note To use apiHandlers, update to @cloudflare/workers-oauth-provider v0.0.4 or later. With these few changes, your MCP server will support both transport methods, making it compatible with both existing and new clients. Testing with MCP clients While most MCP clients have not yet adopted the new Streamable HTTP transport, you can start testing it today using mcp-remote ↗ , an adapter that lets MCP clients that otherwise only support local connections work with remote MCP servers. Follow this guide for instructions on how to connect to your remote MCP server from Claude Desktop, Cursor, Windsurf, and other local MCP clients, using the mcp-remote local proxy ↗ . Was this helpful? Edit page Last updated: Aug 15, 2025 Previous Tools Next McpAgent — API Reference Resources API New to Cloudflare? Directory Sponsorships Open Source Support Help Center System Status Compliance GDPR Company cloudflare.com Our team Careers Tools Cloudflare Radar Speed Test Is BGP Safe Yet? RPKI Toolkit Certificate Transparency Community X Discord YouTube GitHub © 2025 Cloudflare, Inc. Privacy Policy Terms of Use Report Security Issues Trademark Cookie Settings",
    "metadata": {
      "source": "https://developers.cloudflare.com/agents/model-context-protocol/transport/",
      "chunk_index": 0,
      "total_chunks": 1
    }
  }
]